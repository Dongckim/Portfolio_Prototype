{"componentChunkName":"component---src-templates-blog-template-js","path":"/opengl-image-texturing/","result":{"data":{"cur":{"id":"94154dfe-8cbb-509b-bbbb-bb13942ed803","html":"<p>ⓒ 2019. <a href=\"https://media.korea.ac.kr/people/jhan/\">JungHyun Han</a> Korea University Seoul, All rights reserved.</p>\n<br/>\n<h2 id=\"fragment-shader\" style=\"position:relative;\"><a href=\"#fragment-shader\" aria-label=\"fragment shader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fragment Shader</h2>\n<ul>\n<li>Lighting</li>\n<li>Texturing</li>\n</ul>\n<h3 id=\"texel\" style=\"position:relative;\"><a href=\"#texel\" aria-label=\"texel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>texel</h3>\n<ul>\n<li>texture element의 약자. texcel</li>\n</ul>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#fragment-shader\">Fragment Shader</a></p>\n<ul>\n<li><a href=\"#texel\">texel</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"ⓒ 2019. JungHyun Han Korea University Seoul, All rights reserved. Fragment Shader Lighting Texturing texel texture element의 약자. texcel Fragment Shader texel","frontmatter":{"date":"September 27, 2024","title":"OpenGL ES 3차원 컴퓨터그래픽스 이미지 텍스쳐링","categories":"OpenGL","author":"ALEX","emoji":"🥽"},"fields":{"slug":"/opengl-image-texturing/"}},"next":{"id":"3e43c37b-8233-5692-a5ad-61ebe96f9090","html":"<p>ⓒ 2019. <a href=\"https://media.korea.ac.kr/people/jhan/\">JungHyun Han</a> Korea University Seoul, All rights reserved.</p>\n<br/>\n<h2 id=\"gpu-rendering-pipeline\" style=\"position:relative;\"><a href=\"#gpu-rendering-pipeline\" aria-label=\"gpu rendering pipeline permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GPU Rendering Pipeline</h2>\n<p>GPU 렌더링은 다양한 과정을 걸쳐서 나타나는데,</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA/UlEQVQY012OvUrDYBhGcyOuXomb4OQVOLg46uINOLiK4OIfii6FgoNUKo1ZFMWSplWItRKrbUy0knyJJV8C/Y4kzSAeeN6f5eFoSinyUO48E6WQaUoYBMSRIMtSLMviudcjx2hUuTg/LW6lJmVU8WuUKP6QScT3F/FYEsQpzpuHabb4dAfYHZPDgy3qVw3+k5dq+RBRxMjzUTKh7Ql2mn30QYIcXjO62WDc2kaELkdtl5MHD/njI+42yT7u0Y09VldmcZzXqWFemEhJHIaFmd4PWao02X2MSbpV/MoiorbMcGCzVnti/fIF/71Dd3+e2D7j1jhmYW6GujE1/gU1bCDEZ1dFzwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"rendering\"\n        title=\"rendering\"\n        src=\"/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/37523/rendering.png\"\n        srcset=\"/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/e9ff0/rendering.png 180w,\n/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/f21e7/rendering.png 360w,\n/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/37523/rendering.png 720w,\n/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/302a4/rendering.png 1080w,\n/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/07a9c/rendering.png 1440w,\n/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/8c48a/rendering.png 2096w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>\n<p>polygon mesh가 GPU안으로 입력되면, polygon mesh의 정점들은 vertex array에 저장이 되어 있을 것이다.</p>\n</li>\n<li>\n<p>해당 정점들을 vertex shader가 한번에 하나씩 불러들이면서 연산을 하기 시작함.</p>\n</li>\n<li>\n<p>rasterizer를 통해 index array에 있는 정보를 바탕으로 삼각형을 조립하기 시작. 조립된 삼각형은 화면 안에서 여러개의 픽셀을 품고 있을텐데, 이때 각각의 픽셀의 색상을 결정할 정보를 rasterizer가 모아서 각 픽셀 위치마다 저장을 해놓는다.(= fragment)</p>\n</li>\n<li>\n<p>fragment shader를 통해서 각 fragment의 색깔을 결정한다.</p>\n</li>\n<li>\n<p>마지막으로, output merger가 결정된 색상을 보여줄 건지, 말건지를 결정해서 최종 스크린에 뿌려주게 된다.</p>\n</li>\n</ol>\n<p>이 모든 일련의 과정을 <strong>GPU Rendering Pipeline</strong>이라고 한다.</p>\n<br/>\n<blockquote>\n<p>특히, 이 과정에서 등장하는 shader라는 것은 곧, 프로그램을 의미하기 때문에 프로그램을 짜주어야 한다.\n반면에, rasterizer나 output merger는 하드웨어 그 자체이기 때문에, 정해진 것만 실행하는 역할을 한다고 생각하면 될 것 같다.</p>\n</blockquote>\n<br/>\n<h2 id=\"vertex-shader\" style=\"position:relative;\"><a href=\"#vertex-shader\" aria-label=\"vertex shader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Vertex Shader</h2>\n<p>vertex shader가 작동될 때는, object space에 있는 물체를 clip space로 전환하는 과정이 일어난다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 13.333333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAxElEQVQI1z3KzWrCQABF4TxttTQu6q59GqtRKn0Bd64FhXZhFTt1EtJoaycZDNL8zDhHCMXFgcvH9bTNyEyKwaB+FYefQ7O1TZvsv+d5Tk1FZhTHs+ZUnJBb2fxLCvQ55eg0Xmfnc5u0Wdg5sYiJPiJm9YzO3sf/vmNZLwk3IfFnzNRMaUU3dNU9ohCIlSCRCRM3of3V4jF/wAuqEU9VgCQES9PWSQblkEE9ZOf2V393a/plwMg8o1x69Vf3Ru+vz9i8cAEBWNYJDjJCagAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"vertexshader\"\n        title=\"vertexshader\"\n        src=\"/static/e7ac1e6f6174cf2df2f27ece7f4f539f/37523/vertexshader.png\"\n        srcset=\"/static/e7ac1e6f6174cf2df2f27ece7f4f539f/e9ff0/vertexshader.png 180w,\n/static/e7ac1e6f6174cf2df2f27ece7f4f539f/f21e7/vertexshader.png 360w,\n/static/e7ac1e6f6174cf2df2f27ece7f4f539f/37523/vertexshader.png 720w,\n/static/e7ac1e6f6174cf2df2f27ece7f4f539f/302a4/vertexshader.png 1080w,\n/static/e7ac1e6f6174cf2df2f27ece7f4f539f/07a9c/vertexshader.png 1440w,\n/static/e7ac1e6f6174cf2df2f27ece7f4f539f/3126c/vertexshader.png 1876w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>OS → WS 과정은 앞에서 배운 것과 동일하다.</em></p>\n<p>다만, 우리가 배운 transform의 과정에서 normal에 대한 transform은 배우지 않았는데,</p>\n<ul>\n<li>scaling, translation, rotation과 같은 affine 변환을 거친 후에 normal 벡터는, 결국 모든 과정을 거친 행렬을 [L|t] 라고 정의했을 때, <code class=\"language-text\">Ln + t</code>의 공식을 적용할 수 있고, 이때 <code class=\"language-text\">+ t</code> 부분은 아무런 영향을 주지 않기 때문에, <code class=\"language-text\">Ln</code>으로 normal 들이 바뀐다는 것이다.</li>\n</ul>\n<p><strong>만약 non-uniform scaling이라면?</strong></p>\n<p>이 때는 L의 <code class=\"language-text\">역행렬 연산</code> 후 <code class=\"language-text\">전치행렬 처리</code>를 해주면 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABFElEQVQY002QbUvEMBCE+/9/lOCJIOcHFZEetke1pRWbbtKXS9okbUeyEr2BYUPYfTLZZN93uG1j+31nB+1X9dpR27ZhXVcopaC1hjEGzjkko3N4LEs8NQ2OH5+4P5/RKMVDodE7h2sty4JpmtD3PbtpGkgp+c5ai0RZi7ssw3N6wu05OEdFMkQDtQKGBAYzgTpiQEwW0oTati0ulwuICPM8I+mtxUNZ4qWq8FZkeKUOrdYgIaD6AVp8YxwljJk5cVSABXj4angorocT3qQpDnmOY5bjkJ5QDwM3dJLwVdfQUkEbw5C4v6qqUBQFJ+y67h9ovEdGhHchkEmJtBUYl4UbnPe/u3EW3nsGxcF4DumEEH/AH10wy/+7wgweAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"inversetranspose\"\n        title=\"inversetranspose\"\n        src=\"/static/17de61508a96faab4cebac5a811b0cf8/37523/inversetranspose.png\"\n        srcset=\"/static/17de61508a96faab4cebac5a811b0cf8/e9ff0/inversetranspose.png 180w,\n/static/17de61508a96faab4cebac5a811b0cf8/f21e7/inversetranspose.png 360w,\n/static/17de61508a96faab4cebac5a811b0cf8/37523/inversetranspose.png 720w,\n/static/17de61508a96faab4cebac5a811b0cf8/302a4/inversetranspose.png 1080w,\n/static/17de61508a96faab4cebac5a811b0cf8/07a9c/inversetranspose.png 1440w,\n/static/17de61508a96faab4cebac5a811b0cf8/0ff19/inversetranspose.png 2084w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>즉, vertex에 L을 적용할 때, triangle normal에는 L의 <code class=\"language-text\">역행렬 연산</code> 후 <code class=\"language-text\">전치행렬 처리</code>를 적용해야 한다.</li>\n<li>정점 포지션과, 정점 Normal은 서로 다른 변화에 의해 다른 적용을 연산받아야 한다는 점을 알 수 있다.</li>\n</ul>\n<p><strong>uniform-scaling과 rotation</strong></p>\n<p>여기서는 마찬가지로 동일하게 L을 적용하면 되는데, 위의 경우와 마찬가지로 L의 <code class=\"language-text\">역행렬 연산</code> 후 <code class=\"language-text\">전치행렬 처리</code>를 적용해도 같은 값이 나오므로 헷갈리지 말고 그냥 동일하게,</p>\n<p>L의 <code class=\"language-text\">역행렬 연산</code> 후 <code class=\"language-text\">전치행렬 처리</code> 로 외우면 될 것 같다.</p>\n<blockquote>\n<p>지금까지는 triangle normal을 기준으로 살펴보았는데, 사실 알고보면 vertex array에 들어가 있는 것은 vertex normal들이기 때문에 vertex normal에 대한 내용을 알아야 한다.</p>\n</blockquote>\n<br/>\n<h3 id=\"camera-space\" style=\"position:relative;\"><a href=\"#camera-space\" aria-label=\"camera space permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Camera Space</h3>\n<ul>\n<li>\n<p>AT : 내가 기준으로 삼는 3차원 좌표를 AT이라고 한다.</p>\n</li>\n<li>\n<p>EYE : 어디를 찍겠다는 것을 그냥 EYE라고 칭한다.</p>\n</li>\n<li>\n<p>UP : 카메라의 기울기를 정의할 수 있는 카메라의 법선벡터를 UP이라고 정의한다.</p>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABOUlEQVQoz31SXWvCMBTt//8xwh6EjT3sWdnWqcMKioNujTUNaWI/bZOekWhrq+KBEC735txz7o2DKzRNY+8kOZgIp7AZ5LTWOB6PUEpBHiSKoujyTr+w/2A6naMsK9zLV1UFzjk4Y1guvvEb7G4J29PCfV+AMY7rfL/G4MBjRJReCLuC9tIaZVmeCzQeobXaV28V1vXJmrda4Xk8Rp6mqOvaEptH5jYzM6NQWiEWEk+jEf58/yyiGVre8z0oI/C+Zlh6XtedUorNZgNCiCU1JxQEZLvFZDKxTa9nbAk/Zy7eXl7RVJclGEWMMazXayRJYjcahiHc+QfSWN5YHViOogg/PkHIM2vLwKgRQiAIgm4ZJt7tKPxQIM2KwcJaOP0hGzKt23+YQEqJPM+t2iw7NVOqtsrjWNwl/AeadbsjYk40mQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"camera\"\n        title=\"camera\"\n        src=\"/static/b363c19aef2b22ac0171fea6b856143f/37523/camera.png\"\n        srcset=\"/static/b363c19aef2b22ac0171fea6b856143f/e9ff0/camera.png 180w,\n/static/b363c19aef2b22ac0171fea6b856143f/f21e7/camera.png 360w,\n/static/b363c19aef2b22ac0171fea6b856143f/37523/camera.png 720w,\n/static/b363c19aef2b22ac0171fea6b856143f/302a4/camera.png 1080w,\n/static/b363c19aef2b22ac0171fea6b856143f/07a9c/camera.png 1440w,\n/static/b363c19aef2b22ac0171fea6b856143f/0ef7e/camera.png 1594w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>해당 공식을 통해, {u, v, n}은 모두 수직인 관계임을 알 수 있고, 이는 orthonormal하다고 볼 수 있다. 거기에 EYE가 원점 역할을 하기 때문에 완벽한 3차원 좌표계를 구성한다고 볼 수 있다.</p>\n<ul>\n<li>이때 cross product한 값을 normalize를 하지 않은 이유는, 두 벡터가 이루는 평행사변형의 넓이가 cross product의 값이 되는데 이때 단위벡터 두개가 90도를 이루기 때문에, 넓이 또한 1이 될 수 밖에 없기에 굳이 하지 않아도 되는 것이다.</li>\n</ul>\n<h2 id=\"view-transform\" style=\"position:relative;\"><a href=\"#view-transform\" aria-label=\"view transform permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>View Transform</h2>\n<p>가장 주된 목표는, 월드 공간에서 카메라 공간으로의 변환이 가장 큰 목표가 될 것 같다.</p>\n<ul>\n<li>1단계. 원점 맞춰기 (eye = O)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABI0lEQVQoz3VR3W6DIBj1/d9m3rTZfW+2e82S2apTJq6C1U5BgbNgpsXaHmIAge87Px4cGGOWef4smqZBGIa4h3tnXnvPDtx/bdsiTVPEcYycEGhjoJTaELHwHjF8xiIIArzudrhUFXopoO3QevXWu2c1jgq0JCi+s+nC8XQEY2xpoMYRV16j5RzR8QNd163ee65Ui14IkCwDY/W0H4ZhkTfz7/seJaVg7AIp5couzy1m6fOqwrWuIaR8KF87Fjgnt4KuR0VRwPf9KQQhxM1DrTEYA/YZgb/4qA4HJFkOzjnO5wpFQdcMLZIkASFkk97UzBj8ComfKALf78He3pFmORjjoJTiK8uhRjXxXCTbgmVZbpK1clxLbKZK66mxDVD/r2eGfwChvWbhaNLjAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"chapter\"\n        title=\"chapter\"\n        src=\"/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/37523/chapter.png\"\n        srcset=\"/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/e9ff0/chapter.png 180w,\n/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/f21e7/chapter.png 360w,\n/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/37523/chapter.png 720w,\n/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/302a4/chapter.png 1080w,\n/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/07a9c/chapter.png 1440w,\n/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/82747/chapter.png 2232w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>월드공간 = 카메라 공간을 맞추는 과정에서, 이전에 배웠던 rotation에서 배웠던 e1, e2, e3 벡터와 맞춰지는 공식을 넣어서 생각해볼 수 있을 꺼 같다.</li>\n</ul>\n<p>(<strong>space change = translation + basis change</strong>)</p>\n<ul>\n<li>결론</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAv0lEQVQY032P2U7DMBBF+/8fB4WXShWlpFkcx45jZ7WV5SCbSjzBSDMPI93lnI7j4K/pbIfrHf0wYJ1FaYU2Bt0qjLXcbh98Znesc2zbljSnePZ9x3QG731a2dT4ECirIpk0WmGM5lEWXK4XhKxodMv57YXX93P6hxB+DWPL2KAfepZlSc3WdSUvcoQUCFkjlaQUVTIsRUnbdXxld7L8QVULfPA/hv8hu2fIOI4JK+JHkkY1TPOcQqN+mifWJ/I3o5QyPGvFZGkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"matrix\"\n        title=\"matrix\"\n        src=\"/static/d14217f8b41f9b0293fde8e53b1e542f/37523/matrix.png\"\n        srcset=\"/static/d14217f8b41f9b0293fde8e53b1e542f/e9ff0/matrix.png 180w,\n/static/d14217f8b41f9b0293fde8e53b1e542f/f21e7/matrix.png 360w,\n/static/d14217f8b41f9b0293fde8e53b1e542f/37523/matrix.png 720w,\n/static/d14217f8b41f9b0293fde8e53b1e542f/302a4/matrix.png 1080w,\n/static/d14217f8b41f9b0293fde8e53b1e542f/58354/matrix.png 1396w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n우리가 원했던 카메라 좌표계의 좌표였는데 이미 두 좌표가 동일하게 된 상태이므로 그냥 월드좌표를 그대로 따오면 될 꺼 같다.</p>\n<p>Mview  is applied to all objects in the world space to transform them into the camera space</p>\n<ul>\n<li>이런 space/basis change는 컴퓨터 그래픽스나 컴퓨터 비전, 증강현실, 로보틱스 모든 분야에 정말 중요한 역할을 한다. (3차원을 다루는 모든 분야)</li>\n</ul>\n<br/>\n<h3 id=\"right-hand-vs-left-hand\" style=\"position:relative;\"><a href=\"#right-hand-vs-left-hand\" aria-label=\"right hand vs left hand permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Right-hand vs Left-hand</h3>\n<p>RHS 좌표계에서 정의된 것을 LHS로 좌표계를 옮기게 된다면, 이는 다른 현상을 보일 것이다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABwElEQVQoz2WSTY/TMBCG+++RuHHkwJ0DHBAXQAKBFgm0LIXtBSQuFS1t2qVJ7KT+th9kt65adqQoHicz837MBCCllF947+m6nhr13lqL6AXnkWLEeV9qQginfyf5UJP84e7vlvWiwQl5KlZaMaqxnNu2RQhRBhsl0VbRSUnfd4eG50hICekls09zNi9f4WMghoj2ik27pWk2rNdr+l7gzcDNHGYPnpBePEOECDFeIhSj5c+qwcieYZBY58r9atvz5XqG2DRHJpFRtnz+ofj+/Ap3+5V23FeEuSFYF0vDjCgYUzTKEWNESIV3nuh9yctwIbFaYvH0WjMO8pJyZa2UIh6TitxZi5TynlmHienCrBPl+ggpTihq4QGlKBrXu0FKpHWYvB1moBeHugn/xW6/w4VE1jgX1+a7fUvFEpyjMxb//i0/Hz5mugA99GhjDgiz+GpvspAsm4a75Zrg/HE3Hb8XK64+TlFdRwwBawyt0vDtmumjp7y59Tgt0dowKY6pkZsPv9i9foc7muKMKYOWy2VZF6UMwZqiZ44xU3aevAfRZcryknKMif0wFFPqks/n85KnFLHW3DMlb0L0gXBmzD+qtVR6GYJ+SgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"RHSLHS\"\n        title=\"RHSLHS\"\n        src=\"/static/27f8be9a12edbbfd0ba5bef7f9725280/37523/RHSLHS.png\"\n        srcset=\"/static/27f8be9a12edbbfd0ba5bef7f9725280/e9ff0/RHSLHS.png 180w,\n/static/27f8be9a12edbbfd0ba5bef7f9725280/f21e7/RHSLHS.png 360w,\n/static/27f8be9a12edbbfd0ba5bef7f9725280/37523/RHSLHS.png 720w,\n/static/27f8be9a12edbbfd0ba5bef7f9725280/302a4/RHSLHS.png 1080w,\n/static/27f8be9a12edbbfd0ba5bef7f9725280/07a9c/RHSLHS.png 1440w,\n/static/27f8be9a12edbbfd0ba5bef7f9725280/cc418/RHSLHS.png 1992w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>사실 z좌표 부호만 바꿔주면, 모두 해결되는 것이다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABuUlEQVQoz2WTP5PTMBDF71szNAyfgoahouRaakq6AzIEhhxMyF3OieMkjiXL+q8fIzsxvsk2krzat0/vrW8AUkp54Xis6VTb79Pk+36/x1rLJWKMaK3R2mCcw1g73r3Jm8uhM5J1sePxywJMN4JKLfq8EIKiKPq1EQ1OS1RZcsgNnRsApwxb07A5Ku4/fqZb/sENdFhXBavVA1VVIaVEK0HVJt6/nWFevqDdbrEh/GeYw7jIuqyR1Q6rFcZ7UooYF/g2X/L0e0kwur+rWklR1tx93SLncw67sn/2yDDEhNI+kxk0OnfLoY3DOT9ql8N7T9e1pGTpYkQpNeaePdkYg/cD2KAto3burNE0+vyFxbnmmSlZn1NdE4hMG2XAdC5s27ZvLLIpriPPxEkIgvfXDLUT/N3UfP/wCTbr3uUYIsI2SNWyLcvB5aZBKM2vnxXd7S31+qnX/GpsDqLmcVWwW6xoyi2hZ5X4cb9kdjdDNU3fRMmG3cnw5t2C46vXiIcVZqphjAnrEtp4bNvine0LGQdeok6CcHay6zqOhwPOKSRQTQZ/dDmDPhd8OIcQsNZc/T0XIkwmIpvyD2lzVI2oBdiBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"znegotion\"\n        title=\"znegotion\"\n        src=\"/static/48f195b987316eef8d76b4f28b375631/37523/znegotion.png\"\n        srcset=\"/static/48f195b987316eef8d76b4f28b375631/e9ff0/znegotion.png 180w,\n/static/48f195b987316eef8d76b4f28b375631/f21e7/znegotion.png 360w,\n/static/48f195b987316eef8d76b4f28b375631/37523/znegotion.png 720w,\n/static/48f195b987316eef8d76b4f28b375631/302a4/znegotion.png 1080w,\n/static/48f195b987316eef8d76b4f28b375631/07a9c/znegotion.png 1440w,\n/static/48f195b987316eef8d76b4f28b375631/263f4/znegotion.png 1996w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br/>\n<h2 id=\"view-frustum\" style=\"position:relative;\"><a href=\"#view-frustum\" aria-label=\"view frustum permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>View Frustum</h2>\n<p>world space상에서의 x,y,z 축은 이제 의미가 없어진다. u,v,n으로 정의된 축을 바탕으로 카메라가 어느 정도의 공간을 잡아낼 것인지를 결정해야겠다.</p>\n<ul>\n<li>4가지 parameter로 결정하는데, fovy(field-of-view-yaxis/시야각), fovx, apsect(종횡비)등등이 있겠다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABAklEQVQY002QzW7CMBCE8/6vQJ8FiVPhUJBQCsVpKwIioSGJiEOcpP75KhsqMdZcPDs7uxvxQN/3jMPAmOc4KenHX5Tqw3/btozjSFVVNFLSFQVlHGOkvJudC/Qv8oY0TVFK0XUd8nymPZ1Qg6EbFMbph8cxm82YTqcsl0u+12sysQuaNjronpFPF0KEhvP5HJEkGGf5uVxJs4xrp7DGBmOe52y3WyaTFxaLV76SD/bpnrzOwN1rIp5Q13Uw+Ulvt46+H9HaYK0LelmWHI9HdkKwidd8JoJ4885q9UZVSrSxRP+j+tU9tdZYa59zgu7hb3g4HCiKC03ThK2MMUG7qXv4H7T7fFp9aQSIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4parameter\"\n        title=\"4parameter\"\n        src=\"/static/4f093c9d7dcb5d6cc745c293778e71ad/37523/4parameter.png\"\n        srcset=\"/static/4f093c9d7dcb5d6cc745c293778e71ad/e9ff0/4parameter.png 180w,\n/static/4f093c9d7dcb5d6cc745c293778e71ad/f21e7/4parameter.png 360w,\n/static/4f093c9d7dcb5d6cc745c293778e71ad/37523/4parameter.png 720w,\n/static/4f093c9d7dcb5d6cc745c293778e71ad/302a4/4parameter.png 1080w,\n/static/4f093c9d7dcb5d6cc745c293778e71ad/07a9c/4parameter.png 1440w,\n/static/4f093c9d7dcb5d6cc745c293778e71ad/3145a/4parameter.png 2112w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>실린더 모형의 경우는 시야각 밖에 있기 때문에 구현되지 않는다.</em></p>\n<ul>\n<li>그래픽스 렌더링에서는 시야각의 앞과 뒤를 일부 잘라내서 표현하는데, n과 f의 파라미터는 near plane과 far plane을 의미한다. 모든 물체들은 음의 z축에 있기 때문에, -n과 -f가 되겠다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABIUlEQVQY012RT2vCMByG+9132WXfZOyww9xwjHkcO4ijooKgs0NoTZsmbfonbfqMVu3BHySE8PK+b5543I5zl0M37FVVYYzBWjtK6jzDpulZ1XXj6sfrLiau66jKkmK3o41jMlNSGEPZ3xUFtbUE6xV/2y1FmhLN5xTH4yW7G/J7U69RChsEVMbwu98jo4hMCPLSkRZqbGWbhmDps1ss+JzN2Cx9/O8vcq2pW4ttm3PDpn9OEpOnmo/XKbvDHpMVnCKFzDPSrMI5N6RLKUmlZPIy4X36xsP9HZvVGqFCtJZnw5FLXSNigVYKrTVt244sr3yEECRJgohjVv4Pz0+Pg1acBIfgRGVbvKu4b9GzcuOnXIEzGvZmYRiilBrY3k7nHP+Xs8uNEofVNgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nfparameter\"\n        title=\"nfparameter\"\n        src=\"/static/6a13ae0ae8bc1ac7a27f6d85a369105b/37523/nfparameter.png\"\n        srcset=\"/static/6a13ae0ae8bc1ac7a27f6d85a369105b/e9ff0/nfparameter.png 180w,\n/static/6a13ae0ae8bc1ac7a27f6d85a369105b/f21e7/nfparameter.png 360w,\n/static/6a13ae0ae8bc1ac7a27f6d85a369105b/37523/nfparameter.png 720w,\n/static/6a13ae0ae8bc1ac7a27f6d85a369105b/302a4/nfparameter.png 1080w,\n/static/6a13ae0ae8bc1ac7a27f6d85a369105b/07a9c/nfparameter.png 1440w,\n/static/6a13ae0ae8bc1ac7a27f6d85a369105b/f60cd/nfparameter.png 2318w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>truncated pyramid</em></p>\n<ul>\n<li>이렇게 잘린 피라미드 모형의 시야각 외의 물체들은 내가 안보겠다, 라고 선언한 것과 (처리하지 않겠다.) 동일하게 볼 수 있을 것 같다.</li>\n</ul>\n<h3 id=\"view-frustum-culling\" style=\"position:relative;\"><a href=\"#view-frustum-culling\" aria-label=\"view frustum culling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>View Frustum Culling</h3>\n<p>위에서 언급했듯이 머리 잘린 피라미드 (view-frustum)안에 들어와있는 object들 제외하고, 나머지 물체들을 무시하여 렌더링 제외시키는 것을 의미한다.</p>\n<p><strong>Clipping</strong></p>\n<p>view frustum 안에 있는 object이더라도, 어느 부분은 경계선에 닿아 구현되지 않는 부위가 생길 수 있다. 해당 부위를 잘라내는 행위를 우리는 clipping이라고 한다.</p>\n<ul>\n<li>하지만, 현재 view frustum의 형태처럼 비스듬히 있는 모형은 정확하게 잘라서 규정하기 어려운 부분이 있다.</li>\n</ul>\n<br/>\n<h2 id=\"projection-transform\" style=\"position:relative;\"><a href=\"#projection-transform\" aria-label=\"projection transform permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Projection Transform</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABP0lEQVQoz22Sb4vCMAzG9829L+Zr8d4IOzw8YTonzrJ/um6z69r0ORrdUDEQaNP0l/RJAzyMiGCtZffmnHvxMfae62PkHOrrFV3XISiKAnEcI01Tdr/2B8+AEeoBWmsGKqUgCgFrCcZaDEqBjEFwPB6x2WywDkN8L5cQQqCqKrRtyzDVqwnMcCJcygqyaSCuAvTocswJ8izjzsLVCl+zGebzOe/3+z2MNTjLlBN9gbHI+XRCURbYxRGS+ATVDyC6SxWUZQnfZZIkWCwWCMMQf9stDocDLvKC3/UPmrqDbFq0TfPoume41gO6W4+ykpP2gX9eFEUMzLIMeZ5zh33fs1ZStkhzicEQX3gehnMEaww/ewKyuEJASjkJ/sl8XlvX0Lcb5zwPbCzAwE+X378MkcNgDAateSj3GLEbY16+2j8XvGkhuH6VngAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"projectTransform\"\n        title=\"projectTransform\"\n        src=\"/static/09d5151ca79b2dd617223a6c3b415f72/37523/projectTransform.png\"\n        srcset=\"/static/09d5151ca79b2dd617223a6c3b415f72/e9ff0/projectTransform.png 180w,\n/static/09d5151ca79b2dd617223a6c3b415f72/f21e7/projectTransform.png 360w,\n/static/09d5151ca79b2dd617223a6c3b415f72/37523/projectTransform.png 720w,\n/static/09d5151ca79b2dd617223a6c3b415f72/302a4/projectTransform.png 1080w,\n/static/09d5151ca79b2dd617223a6c3b415f72/07a9c/projectTransform.png 1440w,\n/static/09d5151ca79b2dd617223a6c3b415f72/7ef4c/projectTransform.png 1748w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>정육면체로 공간을 조정하면, 변환 자체는 안에 있는 object들에게 모두 적용되어야 할 것이다. 이렇게 정육면체로 조정되면 clipping하기 매우 편할 것이다.</p>\n<p>우리는 이 조정하는 과정을 <strong>projection transform</strong>이라고 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABFElEQVQY012Ra07DMBCEe/9DwQ9OQBEVrZO2pKZJsWM78aN2+hi0WwGFlVaWpfGnmfHsfD7DWgvvPUopuJ/r9Yp4jHzeb4wRKSUYZzD6ESEEEIdmRpDROUzTBOccw0kc4sQClRT+jxsGTLlg3+9hvYEzFjnnG/CUM+qXOeTbAurzgGEY0LYt5q81lFJYbRdwPsPHwgkoiV7XcN0B9a7GWr5js92xSwZeLheslks8PT5ACMHuuq7D80sFKSXWQqAfEnz6BW6EgGx2sNZA9xbyo+MaGEhRSZQp+jjCGMPONtuWBSFGHFP8E1n3PWvJ1TElaK3uIp9O3B1FJXcMCQFVVfG9aRpo3f98Ei3pv5feaa1Ryq3zL0cqy47Z4XJJAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"projection\"\n        title=\"projection\"\n        src=\"/static/054a3161a9b1c6e86a06dc979b304300/37523/projection.png\"\n        srcset=\"/static/054a3161a9b1c6e86a06dc979b304300/e9ff0/projection.png 180w,\n/static/054a3161a9b1c6e86a06dc979b304300/f21e7/projection.png 360w,\n/static/054a3161a9b1c6e86a06dc979b304300/37523/projection.png 720w,\n/static/054a3161a9b1c6e86a06dc979b304300/302a4/projection.png 1080w,\n/static/054a3161a9b1c6e86a06dc979b304300/07a9c/projection.png 1440w,\n/static/054a3161a9b1c6e86a06dc979b304300/1ffbd/projection.png 2108w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>사실 l1과 l2는 원근법에 의해서 길이가 같게 보이는 것인데, projection transform을 하는 순간, 3차원 공간이기 때문에 그냥 같아지는 것이 된다.</li>\n</ul>\n<p>컴퓨터 그래픽스에서는 투영을 시킬 때, 3차원의 모습을 2차원으로 바꿔서 투영시키는 방식이 아닌, 3차원을 그대로 유지하면서 투영의 효과(원근법과 같은)를 달성할 수 있는 것이다.</p>\n<br/>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 16.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAx0lEQVQI102OwUrDQBiE89i+gVK8SRUPPoAgeNBePAntpYIggaiHmpC22oTsn03cDZtkg58keHDgY+Y0M4ExhjzPcc7RdR3e+8ld6/ivnz9fRMJs9YV+ucY+HLEMI46XGdunW7LHcwIRoWmaiTHX9fc0UIqm6i1Jk6KqCqU0+/aTdzkQxZpDEfORrdns9oRJQVy+keavBGNR3/cMwzA9G1FS4O3Asws5KWckVYoozby+4N7e4aVlZdacmjPSeosuhUt7xY1d8AvDWtweJtKsYwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"matrixOfProjection\"\n        title=\"matrixOfProjection\"\n        src=\"/static/ab81fc20e4aee6710fb1a895c91ef83a/37523/matrixOfProjection.png\"\n        srcset=\"/static/ab81fc20e4aee6710fb1a895c91ef83a/e9ff0/matrixOfProjection.png 180w,\n/static/ab81fc20e4aee6710fb1a895c91ef83a/f21e7/matrixOfProjection.png 360w,\n/static/ab81fc20e4aee6710fb1a895c91ef83a/37523/matrixOfProjection.png 720w,\n/static/ab81fc20e4aee6710fb1a895c91ef83a/302a4/matrixOfProjection.png 1080w,\n/static/ab81fc20e4aee6710fb1a895c91ef83a/07a9c/matrixOfProjection.png 1440w,\n/static/ab81fc20e4aee6710fb1a895c91ef83a/701e9/matrixOfProjection.png 1780w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>따라서 초기에 주어진 <strong>fovy</strong>, <strong>aspect</strong>, <strong>n</strong>, <strong>f</strong> 이렇게 4가지의 파라미터가 주어진다면, 내가 카메라 공간의 어느 부분을 보겠다라는 것을 정의하는 것과 같다.</p>\n<ul>\n<li>\n<p>강체변환(rigid-body)과 비강체변환의 차이를 알 수 있다.</p>\n</li>\n<li>\n<p>레스터라이저에서는 LHS로 하드웨어가 설정되어 있기 때문에, Vertex Shaders는 RHS로 처리된 좌표를 LHS로 변환해서 레스터라이저로 전달해야 한다. (<strong>z-negation</strong>) → only 3행만.</p>\n</li>\n</ul>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#gpu-rendering-pipeline\">GPU Rendering Pipeline</a></p>\n</li>\n<li>\n<p><a href=\"#vertex-shader\">Vertex Shader</a></p>\n<ul>\n<li><a href=\"#camera-space\">Camera Space</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#view-transform\">View Transform</a></p>\n<ul>\n<li><a href=\"#right-hand-vs-left-hand\">Right-hand vs Left-hand</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#view-frustum\">View Frustum</a></p>\n<ul>\n<li><a href=\"#view-frustum-culling\">View Frustum Culling</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#projection-transform\">Projection Transform</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 25, 2024","title":"OpenGL ES 3차원 컴퓨터그래픽스 정점 처리","categories":"OpenGL","author":"ALEX","emoji":"🥽"},"fields":{"slug":"/opengl-vertex-processing/"}},"prev":{"id":"105f9487-d300-558b-aa26-252d02d3efa2","html":"<p>ⓒ 2019. <a href=\"https://media.korea.ac.kr/people/jhan/\">JungHyun Han</a> Korea University Seoul, All rights reserved.</p>\n<br/>\n<h2 id=\"gpu-rendering-pipeline-all-transforms\" style=\"position:relative;\"><a href=\"#gpu-rendering-pipeline-all-transforms\" aria-label=\"gpu rendering pipeline all transforms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GPU Rendering Pipeline, All Transforms</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABhElEQVQoz41S7XKDIBD0/V8vPzO2jdH4AaIiIiCwnWMSa5p22p1hFO7Yu2M3izGCFsFaC72uoK1zDmpRe+yR933/HdkxoFeDaRjS/6wUrkXx4+XfyGllx8Rt85ilxCwnaL1imiaYdd3jNME8zy8kR/LsEXxAG4fr9Yrb7QbvPUII6TzEANH3WA8FXkAdCiGQ5znGaUKwFpEuWAt4j2Mx3nO0TbvfbZoGl8sF2+ZSYTnPMMYgo7HqusYkJaJSCG0D37aIh9GosnUOLnxN0nUdyrqG9h7GOlhjEnHGGMP5fAbjHEEpxJ4jcI5NypSwwzlA9Il8xzgCJBzFHioPw4C3PAd947LA931aTsokAus6cCEQxhH+8oFNa3SMgfcCnnXw7++wUqKsqiRYRq0XRZE6JMI4CEQiUApa6yROVVXJl4RlWVCWZXqm9X5G3iUO0iN7UolGZgyhbRHub/gs4quR490FT8amTpI1rIWnLknpbUP8w8Q/GpvaP51OaYxj/XjoKOL/+AR9Oak8fUwcJAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"revisit\"\n        title=\"revisit\"\n        src=\"/static/aaf1a7b61268e15d5ccf165b4c37975f/37523/revisit.png\"\n        srcset=\"/static/aaf1a7b61268e15d5ccf165b4c37975f/e9ff0/revisit.png 180w,\n/static/aaf1a7b61268e15d5ccf165b4c37975f/f21e7/revisit.png 360w,\n/static/aaf1a7b61268e15d5ccf165b4c37975f/37523/revisit.png 720w,\n/static/aaf1a7b61268e15d5ccf165b4c37975f/302a4/revisit.png 1080w,\n/static/aaf1a7b61268e15d5ccf165b4c37975f/07a9c/revisit.png 1440w,\n/static/aaf1a7b61268e15d5ccf165b4c37975f/3d68f/revisit.png 2282w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>물체가 n개라면 n번의 world transform이 일어날 것이다.</li>\n</ul>\n<br/>\n<h2 id=\"vertex-and-index-arrays\" style=\"position:relative;\"><a href=\"#vertex-and-index-arrays\" aria-label=\"vertex and index arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Vertex and Index Arrays</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABVklEQVQoz0WSC4+CQAyE+f+/zDMxGgUVFTUGkPfuIm+VuUw9vCaFkoWvMy0WRmAcefncpQbQ9z3iOEaappKO42C5XCIIAnkOwxBFnqOua7xeL+z3e0lrAtzTO97vt4AZeZ5jPp/DsW1st1us12usVisB73Y7/Mxm0lBrLc3ZSCn1D/TOLrq++yrUSgnkeDzicrnAtm1sNhscDgdcr1dRmySJAIdhgO/7yLIMFlW1TYs4C1HXFaagQgKphlYII5Q1mywWC+RZhrIs0XXdR2GhYNF/1zTwgwDx7YYsDDG0LZqmEQu0w6SSyR4VUV1RFAJ8Pp8yU4oQy8aUiBKNSms8lEL3B2TnKVgTNgVBzKqqZPbGGKktHvphCqUMvhsBZB605Xme2GTNuZ1OJ7iuKwvjLPkem/M9ztHCOEKZxxc1/TrsSovcKoFUwCSMM+QZlxVFkXzHMdD6L3DQWhoQ5ypQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"vertexindex\"\n        title=\"vertexindex\"\n        src=\"/static/ff3c662f9d7b8e1f09e6db33543fca97/37523/vertexindex.png\"\n        srcset=\"/static/ff3c662f9d7b8e1f09e6db33543fca97/e9ff0/vertexindex.png 180w,\n/static/ff3c662f9d7b8e1f09e6db33543fca97/f21e7/vertexindex.png 360w,\n/static/ff3c662f9d7b8e1f09e6db33543fca97/37523/vertexindex.png 720w,\n/static/ff3c662f9d7b8e1f09e6db33543fca97/302a4/vertexindex.png 1080w,\n/static/ff3c662f9d7b8e1f09e6db33543fca97/07a9c/vertexindex.png 1440w,\n/static/ff3c662f9d7b8e1f09e6db33543fca97/d50e7/vertexindex.png 2280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>texture coordinate라는 좌표도 vertex array에 각 셀에 같이 입력되는데, position, normal과 함께 필수 요소라고 볼 수 있다.</p>\n</li>\n<li>\n<p><strong>GPU는 parallel 프로세서</strong>이기 때문에 각 vertex들이 병렬적으로 처리될 수 있다.</p>\n</li>\n</ul>\n<br/>\n<h2 id=\"opengl-es\" style=\"position:relative;\"><a href=\"#opengl-es\" aria-label=\"opengl es permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OpenGL ES</h2>\n<p>Vertex Shader와 Fragment Shader는 결국 프로그램이기 때문에, 각자가 스스로 API에게 제공을 해야 시스템이 돌아간다.</p>\n<ul>\n<li>Shader를 짜기 위한 GPU에 특화된 언어를 사용해야하는데, 이를 OpenGL ES Shading Language라고 한다.(<strong>GLSL</strong>)</li>\n</ul>\n<h3 id=\"opengl-es-shading-languageglsl\" style=\"position:relative;\"><a href=\"#opengl-es-shading-languageglsl\" aria-label=\"opengl es shading languageglsl permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OpenGL ES Shading Language(GLSL)</h3>\n<p>GLSL은 C언어와 상당히 유사한 면이 있다. 하지만, GLSL은 GPU를 가동시키기 때문에, CPU를 가동시키는 언어들과는 차이가 있을 수 밖에 없다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">vec4</code> 4차원 vector를 제공</p>\n</li>\n<li>\n<p><code class=\"language-text\">ivec3</code> 정수형 3차원 vector 제공</p>\n</li>\n<li>\n<p><code class=\"language-text\">mat3</code>, <code class=\"language-text\">mat4</code> 정사각 행렬</p>\n</li>\n<li>\n<p><code class=\"language-text\">mat3x4</code> 3x4 행렬</p>\n</li>\n</ul>\n<br/>\n<h2 id=\"vertex-shader\" style=\"position:relative;\"><a href=\"#vertex-shader\" aria-label=\"vertex shader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Vertex Shader</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABBklEQVQoz31Si46DIBDk/z/RmJgYNZLWEzTik53LbMqF9tpusgLCDLOzGBHBu2Rc14XjOBBCwL7vumZ8wjDNH8GbTRIsy4K2bTFNk67TZfnFT4R4hOA5uBlj1HGeZ5zn+a+CdC4PI/uOOI4Q59D3PaqqgnNON0lCVfnIoA1N06DrOuwhKD7e75DrguEn3m4Qa9G0LYqigPcek/cKpAKC6SEV+8d/Xkwrjm1DHH4QrYWEACMEOQeZZgWWZYlxHLFtmypiEriuqxLyP8nrutbzXEtmm8kdIBHLZldTl1NnSZZK5nwYBrUm+YzXLr+a+814lkxlVM153mnzqf3f3ieVWWs1+Zxywl+KAMDaXO66YQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"vertexshader\"\n        title=\"vertexshader\"\n        src=\"/static/8e4f6f7b7489b05f4d8958603d7e5633/37523/vertexshader.png\"\n        srcset=\"/static/8e4f6f7b7489b05f4d8958603d7e5633/e9ff0/vertexshader.png 180w,\n/static/8e4f6f7b7489b05f4d8958603d7e5633/f21e7/vertexshader.png 360w,\n/static/8e4f6f7b7489b05f4d8958603d7e5633/37523/vertexshader.png 720w,\n/static/8e4f6f7b7489b05f4d8958603d7e5633/302a4/vertexshader.png 1080w,\n/static/8e4f6f7b7489b05f4d8958603d7e5633/07a9c/vertexshader.png 1440w,\n/static/8e4f6f7b7489b05f4d8958603d7e5633/1e1c3/vertexshader.png 1670w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>Two major inputs</strong></p>\n<ul>\n<li>\n<p><strong>Attributes</strong> : Vertex array를 구성하는 종류들 (ex, position, normal, texture coord) -> 각각의 vertex마다 다 attribute가 다르다.</p>\n</li>\n<li>\n<p><strong>Uniforms</strong> : 각각의 데이터들을 똑같이 적용해야하는 shader의 excution들을 칭한다. (ex, World transform, Projection, view transform)</p>\n</li>\n</ul>\n<p>클립공간에서 정의된 좌표를 출력하는 일은 vertex shader의 의무이다. 해당 좌표들을 bulit-in 변수에 저장한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">300</span> es</span></span>\n\nuniform mat4 worldMat<span class=\"token punctuation\">,</span> viewMat<span class=\"token punctuation\">,</span> projMat\n\n<span class=\"token function\">layout</span><span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 position<span class=\"token punctuation\">;</span>\n<span class=\"token function\">layout</span><span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 normal<span class=\"token punctuation\">;</span>\n<span class=\"token function\">layout</span><span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> in vec2 texCoord<span class=\"token punctuation\">;</span>\n\nout vec3 v_normal<span class=\"token punctuation\">;</span>\nout vec2 v_texCoord<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    gl_Position <span class=\"token operator\">=</span> projMat <span class=\"token operator\">*</span> viewMat <span class=\"token operator\">*</span> worldMat <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    v_normal <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">transpose</span><span class=\"token punctuation\">(</span><span class=\"token function\">inverse</span><span class=\"token punctuation\">(</span><span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>worldMat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    v_textcoord <span class=\"token operator\">=</span> textCoord<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<ul>\n<li>\n<p>3차원 좌표 position, 3차원 좌표 normal, 2차원 좌표 textCood를 attribute로 받는다.</p>\n</li>\n<li>\n<p>in은 입력, out은 출력이다.</p>\n</li>\n<li>\n<p>gl_position값을 얻기 위해서는 행렬 곱을 해야하는데, 선언된 position은 3x3 행렬인 Cartesian 좌표이고, 4x4행렬과 결합을 하기 위해서는 homogeneous coordinate로 바꿔줘야 한다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">vec4(position, 1.0)</code> 이라는 명령어를 통해 바꿔줄 수 있겠다.</p>\n</li>\n<li>\n<p>normal에 대해서는 우리가 배웠듯이 <code class=\"language-text\">L</code> 파트가 필요한데, 이를 <code class=\"language-text\">mat3(worldMat)</code>을 통해서 4x4행렬의 왼쪽 위 부분의 3x3부분을 뽑아낼 수 있다.</p>\n</li>\n<li>\n<p>inverse Transpose를 진행해야 v_normal이 나올 것이다.</p>\n</li>\n</ul>\n<br/>\n<h2 id=\"gl-programgl-api\" style=\"position:relative;\"><a href=\"#gl-programgl-api\" aria-label=\"gl programgl api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GL Program(GL API)</h2>\n<ul>\n<li>GL 명령어는 앞에 gl이 붙는다.</li>\n<li>GL 데이터 타입에는 앞에 GL이 붙는다.</li>\n</ul>\n<p>Shader Object를 만들어야 하는데, <code class=\"language-text\">glCreateShader</code>라는 함수를 통해 만들 수 있다. 이는 <code class=\"language-text\">glCreateShader(GL_VERTEX_SHADER)</code> 이런식으로  안에 argument를 넣어서 만들면 vertex shader과 fragment shader를 구분할 수 있게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">GLuint shader <span class=\"token operator\">=</span> <span class=\"token function\">glCreatorShader</span><span class=\"token punctuation\">(</span>GL_VERTEX_SHADER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glShaderSource</span><span class=\"token punctuation\">(</span>shader<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>source<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glCompileShader</span><span class=\"token punctuation\">(</span>shader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>GLuint = GL unsigned integer type</p>\n</li>\n<li>\n<p>shader object에 실제로 shader코드를 저장하는 것 <code class=\"language-text\">glShaderSource</code>, <code class=\"language-text\">&amp;source</code>를 통해 소스코드를 저장할 수 있다.</p>\n</li>\n<li>\n<p>glCompileShader를 통해 compile 할 수 있다.</p>\n</li>\n</ul>\n<h3 id=\"program-object\" style=\"position:relative;\"><a href=\"#program-object\" aria-label=\"program object permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Program Object</h3>\n<ul>\n<li>vertex shader와 fragment shader가 만들어진 후에, 이 둘을 붙여서 program object라는 걸로 통합을 해야한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">GLuint program <span class=\"token operator\">=</span> <span class=\"token function\">glCreateProgram</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glAttachShader</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">,</span> shader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//glAttachShader(program, fragment_shader);</span>\n<span class=\"token function\">glLinkProgram</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glUseProgram</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>해당 프로그램에다가 <code class=\"language-text\">vertex shader</code>object를 붙여야 하기 때문에 <code class=\"language-text\">glAttachShader</code>함수를 이용한다.</li>\n<li>연결해주기 <code class=\"language-text\">glLinkProgram</code></li>\n<li>사용하기 <code class=\"language-text\">glUseProgram</code></li>\n</ul>\n<h3 id=\"attributes\" style=\"position:relative;\"><a href=\"#attributes\" aria-label=\"attributes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Attributes</h3>\n<p>Polygon Mesh의 데이터들을  <code class=\"language-text\">.obj</code>파일을 통해 vertex array와 index array를 import해올 것이다.</p>\n<ul>\n<li>각각을 가리키는 pointer들을 <code class=\"language-text\">vertices</code>와 <code class=\"language-text\">indices</code>로 설정해보자.</li>\n<li>각각을 <code class=\"language-text\">objData</code>라는 구조체에 모아져 있다고 해보자.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Vertex</span> <span class=\"token punctuation\">{</span>\n    glm<span class=\"token operator\">::</span>vec3 pos<span class=\"token punctuation\">;</span> <span class=\"token comment\">// position</span>\n    glm<span class=\"token operator\">::</span>vec3 nor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// normal</span>\n    glm<span class=\"token operator\">::</span>vec2 tex<span class=\"token punctuation\">;</span> <span class=\"token comment\">// texture coordinates</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">typedef</span> GLushort Index<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">ObjData</span> <span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>Vertex<span class=\"token operator\">></span> vertices<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>Index<span class=\"token operator\">></span> indices<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nObjdata objdata<span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">glm</code>는 OpenGL Mathematics를 의미하는데 유용한 유틸리티이다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 18.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsUlEQVQY042Q2Q6EIAxF/f8vBOOWCCKgwGjclztpk3kfkhNe7tI26/seWmssy4J/3vu+uK4L+77Dew+lFP/HcTBZURQg6rrGPM+47xvTNKHrOoYMVHqeJ57nQUoJWik46yCFQJ7nEELAdIb1GRmMMdySYuTQtm0hpURZlqiqigtpCwr9pARrLXtIRzRNA+ccl2UxRhAhBB6ZJqRQgs7wY11XXnnbNgx+YP3PR4zjiBgCvmn7LwzZqwzDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"residing\"\n        title=\"residing\"\n        src=\"/static/ed1df13edd3a2de10988fa19ab553ec7/37523/residing.png\"\n        srcset=\"/static/ed1df13edd3a2de10988fa19ab553ec7/e9ff0/residing.png 180w,\n/static/ed1df13edd3a2de10988fa19ab553ec7/f21e7/residing.png 360w,\n/static/ed1df13edd3a2de10988fa19ab553ec7/37523/residing.png 720w,\n/static/ed1df13edd3a2de10988fa19ab553ec7/302a4/residing.png 1080w,\n/static/ed1df13edd3a2de10988fa19ab553ec7/07a9c/residing.png 1440w,\n/static/ed1df13edd3a2de10988fa19ab553ec7/6f175/residing.png 2036w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>메모리에 vertex array랑 index array가 로드가 된 것인데, 이를 실제로 렌더링을 진행할 GPU로 옮겨주어야 하는데, 이를 <strong>GPU 메모리에 buffer object를 만든다고 표현한다.</strong></p>\n<ul>\n<li>Vertex array → array buffer object</li>\n<li>Index array → element array buffer object</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">GLuint abo<span class=\"token punctuation\">;</span>\n<span class=\"token function\">glGenBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>abo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> abo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> \n    <span class=\"token punctuation\">(</span>GLsizei<span class=\"token punctuation\">)</span> objData<span class=\"token punctuation\">.</span>vertices<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    objData<span class=\"token punctuation\">.</span>vertices<span class=\"token punctuation\">.</span><span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>Buffer를 생성해서 기존 vertex array를 연결해주고, 해당 데이터를 박아 넣는 느낌으로 이해하면 되겠다.</li>\n</ul>\n<p><strong>index array도 동일하게 진행된다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 11.666666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAZklEQVQI1y2MSQrEMBAD8/+XBoy3dIjTi6khzRxECVHoWGtRa2WMkey901pDRJK5907/2BpmRkSkN/5uplbmnBzxvvhaqAgugl4Xft/48+Bm6MfzREvBSyH2zsNwz3NVxb+uxo7gB4GMmjgOw79CAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bufferObject\"\n        title=\"bufferObject\"\n        src=\"/static/a7aa0a56779bdedd221c4612ab253cc4/37523/bufferObject.png\"\n        srcset=\"/static/a7aa0a56779bdedd221c4612ab253cc4/e9ff0/bufferObject.png 180w,\n/static/a7aa0a56779bdedd221c4612ab253cc4/f21e7/bufferObject.png 360w,\n/static/a7aa0a56779bdedd221c4612ab253cc4/37523/bufferObject.png 720w,\n/static/a7aa0a56779bdedd221c4612ab253cc4/302a4/bufferObject.png 1080w,\n/static/a7aa0a56779bdedd221c4612ab253cc4/07a9c/bufferObject.png 1440w,\n/static/a7aa0a56779bdedd221c4612ab253cc4/8170e/bufferObject.png 2132w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// position = attribute 0</span>\n<span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> GLvoid<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">,</span> pos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// position = attribute 1</span>\n<span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> GLvoid<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">,</span> nor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// position = attribute 2</span>\n<span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> GLvoid<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">,</span> tex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>시작점을 알려주는 것이 굉장히 중요해 보인다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">glEnableVertexAttribArray</code> Vertex array 데이터를 활성화 시키겠다는 것이다.</p>\n</li>\n<li>\n<p>Vertex Shader에서 location 0, 1, 2에 position, normal, texCoord를 할당시켰던걸 기억해야한다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">3, GL_FLOAT</code> → 3차원 원소이면서, 각 원소는 float형태이다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">sizeof(Vertex)</code> = stride</p>\n</li>\n<li>\n<p><code class=\"language-text\">offsetof()</code> → 시작지점을 알려주는 함수</p>\n</li>\n</ul>\n<br/>\n<h3 id=\"uniform\" style=\"position:relative;\"><a href=\"#uniform\" aria-label=\"uniform permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Uniform</h3>\n<p>Our vertex shader has three uniforms: <code class=\"language-text\">worldMat</code>, <code class=\"language-text\">viewMat</code>, and <code class=\"language-text\">projMat</code>.</p>\n<ul>\n<li>매 씬마다 world matrix는 변동될 것이다.</li>\n<li>카메라가 움직인다고 생각해봐도 view matrix는 계속 변동될 것임을 알 수 있다.</li>\n<li>projection matrix는 4가지 파라미터, fovy, aspect, n, f 이것들이 변하지 않은 이상 변화는 없을 것이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">glm<span class=\"token operator\">::</span>mat4 worldMatrix<span class=\"token punctuation\">;</span> <span class=\"token comment\">// repeatedly updated for a dynamic object</span>\n\nGLint loc <span class=\"token operator\">=</span> <span class=\"token function\">glGetUniformLocation</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">,</span> <span class=\"token string\">\"worldMat\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glUniformMatrix4fv</span><span class=\"token punctuation\">(</span>loc<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">value_ptr</span><span class=\"token punctuation\">(</span>worldMatrix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p><code class=\"language-text\">glGetUniformLocation</code> 프로그램 오브젝트 world 행렬의 위치를 찾아낼 수 있다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">worldMat</code>과 <code class=\"language-text\">worldMatrix</code>는 다르다. worldMat은 shader가 갖고 있는 변수이고, worldMatrix는 openGL ES가 갖고 있는 변수가 되겠다.</p>\n</li>\n<li>\n<p>위치를 확인한 그 변수를 shader variable 자리에 넣어주면 된다.</p>\n</li>\n</ul>\n<br/>\n<h3 id=\"drawcalls\" style=\"position:relative;\"><a href=\"#drawcalls\" aria-label=\"drawcalls permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Drawcalls</h3>\n<p>모든게 마무리 되면 이제 그리기만 하면 되겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">144</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>index array없이도 이런식으로 호출이 가능하다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">glDrawElement</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">144</span><span class=\"token punctuation\">,</span> GL_UNSIGNED_SHORT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<ul>\n<li>element = 결국 index라는 점을 인지해야겠다.</li>\n</ul>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#gpu-rendering-pipeline-all-transforms\">GPU Rendering Pipeline, All Transforms</a></p>\n</li>\n<li>\n<p><a href=\"#vertex-and-index-arrays\">Vertex and Index Arrays</a></p>\n</li>\n<li>\n<p><a href=\"#opengl-es\">OpenGL ES</a></p>\n<ul>\n<li><a href=\"#opengl-es-shading-languageglsl\">OpenGL ES Shading Language(GLSL)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#vertex-shader\">Vertex Shader</a></p>\n</li>\n<li>\n<p><a href=\"#gl-programgl-api\">GL Program(GL API)</a></p>\n<ul>\n<li><a href=\"#program-object\">Program Object</a></li>\n<li><a href=\"#attributes\">Attributes</a></li>\n<li><a href=\"#uniform\">Uniform</a></li>\n<li><a href=\"#drawcalls\">Drawcalls</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 27, 2024","title":"OpenGL ES 3차원 컴퓨터그래픽스 GL & Shader","categories":"OpenGL","author":"ALEX","emoji":"🥽"},"fields":{"slug":"/opengl-es-shader/"}},"site":{"siteMetadata":{"siteUrl":"https://dongckim.github.io","comments":{"utterances":{"repo":"dongckim/dongckim.github.io"}}}}},"pageContext":{"slug":"/opengl-image-texturing/","nextSlug":"/opengl-vertex-processing/","prevSlug":"/opengl-es-shader/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}