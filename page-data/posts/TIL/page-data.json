{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/TIL","result":{"pageContext":{"currentCategory":"TIL","categories":["All","회고","iOS","TIL","Git","트러블슈팅"],"edges":[{"node":{"id":"83a41433-7393-5660-988a-f34d4b133010","excerpt":"UTC(Cordinated Universal Time) 협정 세계시라고 하는 단위인데, 국제적인 표준시간의 기준이라고 한다. 국제 사회가 사용하는 과학적 시간의 표준 기존 평균태양시인 그리니치 표준시(GMT)를 대체하여 사용 (영국 그리니치 천문대 시간 기준.) 우리나라(한국)는 런던을 기준으로 + 9시간 (빠름) Date 구조체의 이해 스위프트에서 기본으로 제공해주는 날짜를 다루는 Date구조체 타입 초, 분, 시간 60초(1분) * 60분(1시간) * 24시간 = 하루를 초기준으로 3600초 3600초 * 24 = 86,400초 (하루) 정의된 타임존 날짜와 시간 다루기 Date/Calender/DateFormatter 날짜를 제대로 다루려면? 달력을 다루는 calendar 구조체의 도움도 필요 (양력, 음력인지) 문자열로 변형해주는 DateFormatter 클래스의 도움도 필요 기본적으로 지역설정/타임존의 영향이 있음. Calendar 구조체의 이해 스위프트에서 기본으로 제공…","fields":{"slug":"/ios-date/"},"frontmatter":{"categories":"iOS TIL","title":"iOS스터디 week7, 스위프트에서 날짜와 시간 다루기","date":"August 23, 2024"}},"next":{"fields":{"slug":"/sesac-interview/"}},"previous":{"fields":{"slug":"/lambda-thon-preview/"}}},{"node":{"id":"82a190e7-35d0-5a58-a4a1-031a43d3b33a","excerpt":"네트워킹 네트워크 연결을 통해 받은 JSON형태 데이터를 다시 클래스나 구조체의 형태로 변환하는 것은 매우 어려운 일이다. 특히 이 작업을 하나하나 손으로 해야한다면 말이다. 구조체로 바꿔주는 사이트 ↑ 위 사이트를 이용한다면 더 쉽게 형태를 바꾸어 서버에서 보내준 데이터를 사용할 수 있을 것이다. 자 이제 우리가 받아온 데이터를 우리가 쓰기 좋게 변환하는 과정(분석)을 해보자. 일단의 예전의 형태를 먼저 보면, 너무 복잡하다… 현재의 스위프트에서는 매우 간략하게 바뀔 수 있다. 궁극적으로 배열로 반환된 데이터를 볼 수 있다. 이때 좀 살펴봐야하는 것이 Decodable이라는 프로토콜이 있는데, 이는 위에어 JSON Decoder를 선택할 때 필요한 프로토콜이라고 생각하면 되겠다. 마찬가지로 Encodable 이라는 프로토콜도 존재하는데, Decodable과는 반대로 구조체나 클래스를 데이터의 형태로 변형시켜주는 프로토콜이라고 한다. decode(변형하고 싶은 객체, from: 데…","fields":{"slug":"/ios-network-async/"},"frontmatter":{"categories":"iOS TIL","title":"iOS 스터디 week6. 스위프트 네트워크와 비동기 프로그래밍","date":"August 14, 2024"}},"next":{"fields":{"slug":"/ios-protocol/"}},"previous":{"fields":{"slug":"/sesac-interview/"}}},{"node":{"id":"b4d25bb3-2a52-51d9-b1e6-4b9268ce3a23","excerpt":"프로토콜 프로토콜은 타입이다. 함수를 호출할 때, “프로토콜”을 파라미터로 전달할 수 있음. 함수에서 “프로토콜”을 반환할 수 있음. “프로토콜”을 변수에 할당할 수 있음. 구조체, 열거형, 클래스랑 비슷한 타입이라는 뜻이다. → 일급객체로 취급한다.(타입으로 사용하는 조건) 인스턴스를 찍어낼 때 프로토콜로 지정해서 찍어내면, 프로토콜 선언 메서드들만 사용할 수 있다.\n그 외에 해당 함수의 프로토콜에서 지정된 함수 이외에 다른 메서드를 지정하고 싶다면, 다운캐스팅을 하면 된다. 프로토콜 타입 취급의 장점 배열로 담을 수 있음. 파라미터로 사용할 수 있음. 프로토콜의 준수성 검사 특정타입이 프로토콜을 채택하고 있는지 확인 프로토콜 타입으로 저장된 인스턴스가 더 구체적인 타입인지 확인 가능 업캐스팅(as) 무조건 성공 다운캐스팅(as?/as!) 프로토콜의 상속 실제로 프로토콜을 이용해서 상속을 하는 경우는 많이 없지만, 애플이 swift내에서 많은 것들을 프로토콜의 상속을 바탕으로 구…","fields":{"slug":"/ios-protocol/"},"frontmatter":{"categories":"iOS TIL","title":"iOS 스터디 week5. 프로토콜","date":"August 07, 2024"}},"next":{"fields":{"slug":"/git-largefile-upload/"}},"previous":{"fields":{"slug":"/ios-network-async/"}}},{"node":{"id":"b3fb622c-559e-5b20-97dd-83212705c66c","excerpt":"구조체의 확장과 생성자 관련 세부사항 확장에서도 생성자를 구현할 수 있지만, 모든 생성자를 구현할 수는 없다. 잘생각해보자\nclass에서 편의생성자는 delegate across로 같은 스코프? 계층에 있는 생성자를 호출\n호출된 지정생성자는 메모리를 찍어내는 역할을 함. 확장에서도, 말 의미 그대로 지정생성자를 추가하기보다는, 편의 생성자만 생성가능 (지정생성자 추가 불가/소멸자 추가 불가) 다만 클래스가 아닌 경우에, 본체에 지정생성자를 호출하는 방법만 가능(convinence는 아니지만, 비슷한 방식)  값타입(구조체)의 경우 저장속성에 기본값/생성자 정의안한 경우, 생성자 구현 가능 클래스에서의 확장예시 구조체에서의 확장 예시 구조체는 (원래) 편의 생성자가 존재하지 않고, 상속과 관련이 없기 때문에 지정생성자의 형태로도 자유롭게 생성자 구현 가능  -> 본체에 멤버와이즈 이니셜라이저랑 기본생성자가 자동 구현이 됨. 따라서 확장에서 같은 기본 생성자를 한번 더 구현하게 되면 …","fields":{"slug":"/ios-extension-init/"},"frontmatter":{"categories":"iOS TIL","title":"iOS 스터디 week4. 구조체의 확장과 생성자 관련 세부사항","date":"July 23, 2024"}},"next":{"fields":{"slug":"/ios-computed/"}},"previous":{"fields":{"slug":"/sesac-hackathon/"}}},{"node":{"id":"38fa7a7b-a348-53ee-a244-d1e136f87988","excerpt":"구조체(struct) and 클래스(class) 이 둘은 모두 객체지향 → 공통적으로 속성값(properties)은 같다. 저장속성, 지연(Lazy)저장속성, 계산속성(Computed), 타입속성, 속성 감시자(observer) 공통적인 속성값 중, 계산속성과 타입속성에 대해 알아보자. 계산속성(Computd Properties) 값이 일반적으로 저장되는 일반적인 속성(변수)를 저장 속성이라고 한다. 지금까지는 변수선언 부 밑에 매서드를 작성하여 간단하게 리턴하는 방식을 사용하였다. 이 방식은 단순이 계산 속성이라기 보다는, 저장속성으로 저장 value들을 이용하여 계산 문법을 실행한 결과값을 리턴했다고 보는게 맞겠다. 밖에서 해당 인스턴스에 접근해서 “get”, 값을 얻는다는 의미이다. 어떻게 보면 저장속성이라고 볼 수 있지만, 리눅스의 Read속성과 비슷해보인다. 단순히 값을 읽어오는 것도 컴퓨터로서는 계산으로 판단하게 되는 것 같아보임. 항상 다른 저장 속성에 의한 결과로 계…","fields":{"slug":"/ios-computed/"},"frontmatter":{"categories":"iOS TIL","title":"iOS스터디 week3, 계산속성과 저장속성","date":"July 17, 2024"}},"next":{"fields":{"slug":"/ios-enum/"}},"previous":{"fields":{"slug":"/ios-extension-init/"}}},{"node":{"id":"777e34eb-abcf-58dd-8922-3f693ed6efa6","excerpt":"열거형(Enumerations) 타입 자체를 한정된 사례(case)안에서 정의할 수 있는 타입 한정된 사례(정해진 갯수) 안에서 정의할 수 있을때 월 / 화 / 수 / 목 / 금 / 토 / 일 동 / 서 / 남 / 북 좌로 정렬 / 가운데 정렬 / 우측 정렬 초등학교 / 중학교 / 고등학교 / 대학교 남 / 여 가위 / 바위 / 보 열거형을 사용하면 코드의 가독성과 안정성이 높아짐 ===> 명확한 분기 처리 가능 열거형의 원시값과 연관값 열거형의 원시값은 매칭되는 기본값(정수/문자열)을 정해, 열거형을 좀 더 쉽게 활용 가능 → Int나 String 형태가 보통 많이 쓰이긴 한다. 원시값 입력안하면 0, 1, 2  이렇게 자동으로 저장됨 (정수의 경우 숫자가 하나씩 증가) 1(설정시), 2, 3 0, 2(설정시), 3 원시값의 활용 숫자 또는 문자열과 매칭시켜 자유롭게 활용 가능 (숫자 ←→ 열거형 타입) 논리적으로 nil이 될 수 없다면, 출력은 하지만 문자열은 아님에 주의 여기…","fields":{"slug":"/ios-enum/"},"frontmatter":{"categories":"iOS TIL","title":"Swift 특이점①, 열거형(Enum)","date":"July 14, 2024"}},"next":{"fields":{"slug":"/ios-collection/"}},"previous":{"fields":{"slug":"/ios-computed/"}}},{"node":{"id":"552137d8-d624-5da4-bd54-072a652417ee","excerpt":"스위프트 컬렉션 데이터를 효율적으로 관리하기 위한 자료형 타입이다. Array : 데이터를 순서대로 저장하는 컬렉션 Dictionary : key: value 하나의 쌍으로 관리 (X순서) Set : X순서, X중복 Array 배열 파이썬에서의  와 많이 유사한 형태이다 배열의 문법 약속 [] 대괄호로 묶는다. 배열의 인덱스의 시작은 0부터 (모든 프로그래밍 언어 공통 사항) 1개의 배열에는 동일한 타입의 데이터만 담을 수 있다. (순서가 있기 때문에) 값은 중복 가능 배열의 기본기능 배열의 각 요소(element)에 대한 접근 서브스크립트를 이용해서 각 요소에 효율적으로 접근할 수 있다. 이 점 또한 파이썬과 매우 유사한 형태 스위프트를 배우면서 제일 많이 느끼는건, 에러처리에 굉장히 쫄아있는(?) 느낌이다. 파이썬에 비하면 정말 과할 정도로 많은 함수를 지원하는데, 공통적으로 모든함수에서, ‘너가 찾으려는 게 없을 수도 있어~‘를 대비하여 옵셔널 처리를 하여 결과값을 보여준다.…","fields":{"slug":"/ios-collection/"},"frontmatter":{"categories":"iOS TIL","title":"iOS스터디 week2, 컬렉션(collection)","date":"July 11, 2024"}},"next":{"fields":{"slug":"/inout-guard-optional/"}},"previous":{"fields":{"slug":"/ios-enum/"}}},{"node":{"id":"7bae10d0-f956-5901-87ae-9d74bd05b415","excerpt":"기존 파이썬이나 자바스크립트 문법을 알고 있기 때문에, 비슷한 방식의 문법구조와 관련된 건 스킵하기로 했다. 다만 Swift에서 꼭 알아야만 하는 문법과 이 언어의 특징과 같은 문법들은 꼼꼼하게 되짚어보자. (사실 이게 더 어려움;;) 1. inout 입출력 파라미터 함수를 통해, 변수를 직접 수정하고 싶은 경우, 함수내의 파라미터는 기본적으로 복사되어 전달되는 값타입(str, string, Int…)이며, 임시상수이기 때문에 변경 불가가 원칙임. 뭐 파이썬처럼 생각해보면 맞지 않을까? 라는 의문이 들 수 있는게 당연하다 (일단 나부터 개추;;) 실제로는 이 코드는 에러블록을 띄우는데, a와 b는 파라미터이기 때문에, 전역변수 scope에 있던 변수들이 복사되어 전달된다 (직접 쓰인다 정도로 이해하면 될 듯) 따라서, 원본이 전달되기 때문에 전역변수의 값이 변경되어서는 안되는 변경 불가가 원칙이다. 이 예시를 보면 파라미터 앞에 inout 키워드를 쓰게되면, 이는 직접 전달 방식보…","fields":{"slug":"/inout-guard-optional/"},"frontmatter":{"categories":"iOS TIL","title":"inout 입출력 파라미터, gaurd문, 옵셔널 바인딩","date":"July 10, 2024"}},"next":null,"previous":{"fields":{"slug":"/ios-collection/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}