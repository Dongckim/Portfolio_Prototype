{"componentChunkName":"component---src-templates-blog-template-js","path":"/opengl-es-shader/","result":{"data":{"cur":{"id":"105f9487-d300-558b-aa26-252d02d3efa2","html":"<p>ⓒ 2019. <a href=\"https://media.korea.ac.kr/people/jhan/\">JungHyun Han</a> Korea University Seoul, All rights reserved.</p>\n<br/>\n<h2 id=\"gpu-rendering-pipeline-all-transforms\" style=\"position:relative;\"><a href=\"#gpu-rendering-pipeline-all-transforms\" aria-label=\"gpu rendering pipeline all transforms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GPU Rendering Pipeline, All Transforms</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABhElEQVQoz41S7XKDIBD0/V8vPzO2jdH4AaIiIiCwnWMSa5p22p1hFO7Yu2M3izGCFsFaC72uoK1zDmpRe+yR933/HdkxoFeDaRjS/6wUrkXx4+XfyGllx8Rt85ilxCwnaL1imiaYdd3jNME8zy8kR/LsEXxAG4fr9Yrb7QbvPUII6TzEANH3WA8FXkAdCiGQ5znGaUKwFpEuWAt4j2Mx3nO0TbvfbZoGl8sF2+ZSYTnPMMYgo7HqusYkJaJSCG0D37aIh9GosnUOLnxN0nUdyrqG9h7GOlhjEnHGGMP5fAbjHEEpxJ4jcI5NypSwwzlA9Il8xzgCJBzFHioPw4C3PAd947LA931aTsokAus6cCEQxhH+8oFNa3SMgfcCnnXw7++wUqKsqiRYRq0XRZE6JMI4CEQiUApa6yROVVXJl4RlWVCWZXqm9X5G3iUO0iN7UolGZgyhbRHub/gs4quR490FT8amTpI1rIWnLknpbUP8w8Q/GpvaP51OaYxj/XjoKOL/+AR9Oak8fUwcJAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"revisit\"\n        title=\"revisit\"\n        src=\"/static/aaf1a7b61268e15d5ccf165b4c37975f/37523/revisit.png\"\n        srcset=\"/static/aaf1a7b61268e15d5ccf165b4c37975f/e9ff0/revisit.png 180w,\n/static/aaf1a7b61268e15d5ccf165b4c37975f/f21e7/revisit.png 360w,\n/static/aaf1a7b61268e15d5ccf165b4c37975f/37523/revisit.png 720w,\n/static/aaf1a7b61268e15d5ccf165b4c37975f/302a4/revisit.png 1080w,\n/static/aaf1a7b61268e15d5ccf165b4c37975f/07a9c/revisit.png 1440w,\n/static/aaf1a7b61268e15d5ccf165b4c37975f/3d68f/revisit.png 2282w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>물체가 n개라면 n번의 world transform이 일어날 것이다.</li>\n</ul>\n<br/>\n<h2 id=\"vertex-and-index-arrays\" style=\"position:relative;\"><a href=\"#vertex-and-index-arrays\" aria-label=\"vertex and index arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Vertex and Index Arrays</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABVklEQVQoz0WSC4+CQAyE+f+/zDMxGgUVFTUGkPfuIm+VuUw9vCaFkoWvMy0WRmAcefncpQbQ9z3iOEaappKO42C5XCIIAnkOwxBFnqOua7xeL+z3e0lrAtzTO97vt4AZeZ5jPp/DsW1st1us12usVisB73Y7/Mxm0lBrLc3ZSCn1D/TOLrq++yrUSgnkeDzicrnAtm1sNhscDgdcr1dRmySJAIdhgO/7yLIMFlW1TYs4C1HXFaagQgKphlYII5Q1mywWC+RZhrIs0XXdR2GhYNF/1zTwgwDx7YYsDDG0LZqmEQu0w6SSyR4VUV1RFAJ8Pp8yU4oQy8aUiBKNSms8lEL3B2TnKVgTNgVBzKqqZPbGGKktHvphCqUMvhsBZB605Xme2GTNuZ1OJ7iuKwvjLPkem/M9ztHCOEKZxxc1/TrsSovcKoFUwCSMM+QZlxVFkXzHMdD6L3DQWhoQ5ypQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"vertexindex\"\n        title=\"vertexindex\"\n        src=\"/static/ff3c662f9d7b8e1f09e6db33543fca97/37523/vertexindex.png\"\n        srcset=\"/static/ff3c662f9d7b8e1f09e6db33543fca97/e9ff0/vertexindex.png 180w,\n/static/ff3c662f9d7b8e1f09e6db33543fca97/f21e7/vertexindex.png 360w,\n/static/ff3c662f9d7b8e1f09e6db33543fca97/37523/vertexindex.png 720w,\n/static/ff3c662f9d7b8e1f09e6db33543fca97/302a4/vertexindex.png 1080w,\n/static/ff3c662f9d7b8e1f09e6db33543fca97/07a9c/vertexindex.png 1440w,\n/static/ff3c662f9d7b8e1f09e6db33543fca97/d50e7/vertexindex.png 2280w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>texture coordinate라는 좌표도 vertex array에 각 셀에 같이 입력되는데, position, normal과 함께 필수 요소라고 볼 수 있다.</p>\n</li>\n<li>\n<p><strong>GPU는 parallel 프로세서</strong>이기 때문에 각 vertex들이 병렬적으로 처리될 수 있다.</p>\n</li>\n</ul>\n<br/>\n<h2 id=\"opengl-es\" style=\"position:relative;\"><a href=\"#opengl-es\" aria-label=\"opengl es permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OpenGL ES</h2>\n<p>Vertex Shader와 Fragment Shader는 결국 프로그램이기 때문에, 각자가 스스로 API에게 제공을 해야 시스템이 돌아간다.</p>\n<ul>\n<li>Shader를 짜기 위한 GPU에 특화된 언어를 사용해야하는데, 이를 OpenGL ES Shading Language라고 한다.(<strong>GLSL</strong>)</li>\n</ul>\n<h3 id=\"opengl-es-shading-languageglsl\" style=\"position:relative;\"><a href=\"#opengl-es-shading-languageglsl\" aria-label=\"opengl es shading languageglsl permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OpenGL ES Shading Language(GLSL)</h3>\n<p>GLSL은 C언어와 상당히 유사한 면이 있다. 하지만, GLSL은 GPU를 가동시키기 때문에, CPU를 가동시키는 언어들과는 차이가 있을 수 밖에 없다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">vec4</code> 4차원 vector를 제공</p>\n</li>\n<li>\n<p><code class=\"language-text\">ivec3</code> 정수형 3차원 vector 제공</p>\n</li>\n<li>\n<p><code class=\"language-text\">mat3</code>, <code class=\"language-text\">mat4</code> 정사각 행렬</p>\n</li>\n<li>\n<p><code class=\"language-text\">mat3x4</code> 3x4 행렬</p>\n</li>\n</ul>\n<br/>\n<h2 id=\"vertex-shader\" style=\"position:relative;\"><a href=\"#vertex-shader\" aria-label=\"vertex shader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Vertex Shader</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABBklEQVQoz31Si46DIBDk/z/RmJgYNZLWEzTik53LbMqF9tpusgLCDLOzGBHBu2Rc14XjOBBCwL7vumZ8wjDNH8GbTRIsy4K2bTFNk67TZfnFT4R4hOA5uBlj1HGeZ5zn+a+CdC4PI/uOOI4Q59D3PaqqgnNON0lCVfnIoA1N06DrOuwhKD7e75DrguEn3m4Qa9G0LYqigPcek/cKpAKC6SEV+8d/Xkwrjm1DHH4QrYWEACMEOQeZZgWWZYlxHLFtmypiEriuqxLyP8nrutbzXEtmm8kdIBHLZldTl1NnSZZK5nwYBrUm+YzXLr+a+814lkxlVM153mnzqf3f3ieVWWs1+Zxywl+KAMDaXO66YQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"vertexshader\"\n        title=\"vertexshader\"\n        src=\"/static/8e4f6f7b7489b05f4d8958603d7e5633/37523/vertexshader.png\"\n        srcset=\"/static/8e4f6f7b7489b05f4d8958603d7e5633/e9ff0/vertexshader.png 180w,\n/static/8e4f6f7b7489b05f4d8958603d7e5633/f21e7/vertexshader.png 360w,\n/static/8e4f6f7b7489b05f4d8958603d7e5633/37523/vertexshader.png 720w,\n/static/8e4f6f7b7489b05f4d8958603d7e5633/302a4/vertexshader.png 1080w,\n/static/8e4f6f7b7489b05f4d8958603d7e5633/07a9c/vertexshader.png 1440w,\n/static/8e4f6f7b7489b05f4d8958603d7e5633/1e1c3/vertexshader.png 1670w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>Two major inputs</strong></p>\n<ul>\n<li>\n<p><strong>Attributes</strong> : Vertex array를 구성하는 종류들 (ex, position, normal, texture coord) -> 각각의 vertex마다 다 attribute가 다르다.</p>\n</li>\n<li>\n<p><strong>Uniforms</strong> : 각각의 데이터들을 똑같이 적용해야하는 shader의 excution들을 칭한다. (ex, World transform, Projection, view transform)</p>\n</li>\n</ul>\n<p>클립공간에서 정의된 좌표를 출력하는 일은 vertex shader의 의무이다. 해당 좌표들을 bulit-in 변수에 저장한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">300</span> es</span></span>\n\nuniform mat4 worldMat<span class=\"token punctuation\">,</span> viewMat<span class=\"token punctuation\">,</span> projMat\n\n<span class=\"token function\">layout</span><span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 position<span class=\"token punctuation\">;</span>\n<span class=\"token function\">layout</span><span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 normal<span class=\"token punctuation\">;</span>\n<span class=\"token function\">layout</span><span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> in vec2 texCoord<span class=\"token punctuation\">;</span>\n\nout vec3 v_normal<span class=\"token punctuation\">;</span>\nout vec2 v_texCoord<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    gl_Position <span class=\"token operator\">=</span> projMat <span class=\"token operator\">*</span> viewMat <span class=\"token operator\">*</span> worldMat <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    v_normal <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">transpose</span><span class=\"token punctuation\">(</span><span class=\"token function\">inverse</span><span class=\"token punctuation\">(</span><span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>worldMat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    v_textcoord <span class=\"token operator\">=</span> textCoord<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<ul>\n<li>\n<p>3차원 좌표 position, 3차원 좌표 normal, 2차원 좌표 textCood를 attribute로 받는다.</p>\n</li>\n<li>\n<p>in은 입력, out은 출력이다.</p>\n</li>\n<li>\n<p>gl_position값을 얻기 위해서는 행렬 곱을 해야하는데, 선언된 position은 3x3 행렬인 Cartesian 좌표이고, 4x4행렬과 결합을 하기 위해서는 homogeneous coordinate로 바꿔줘야 한다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">vec4(position, 1.0)</code> 이라는 명령어를 통해 바꿔줄 수 있겠다.</p>\n</li>\n<li>\n<p>normal에 대해서는 우리가 배웠듯이 <code class=\"language-text\">L</code> 파트가 필요한데, 이를 <code class=\"language-text\">mat3(worldMat)</code>을 통해서 4x4행렬의 왼쪽 위 부분의 3x3부분을 뽑아낼 수 있다.</p>\n</li>\n<li>\n<p>inverse Transpose를 진행해야 v_normal이 나올 것이다.</p>\n</li>\n</ul>\n<br/>\n<h2 id=\"gl-programgl-api\" style=\"position:relative;\"><a href=\"#gl-programgl-api\" aria-label=\"gl programgl api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GL Program(GL API)</h2>\n<ul>\n<li>GL 명령어는 앞에 gl이 붙는다.</li>\n<li>GL 데이터 타입에는 앞에 GL이 붙는다.</li>\n</ul>\n<p>Shader Object를 만들어야 하는데, <code class=\"language-text\">glCreateShader</code>라는 함수를 통해 만들 수 있다. 이는 <code class=\"language-text\">glCreateShader(GL_VERTEX_SHADER)</code> 이런식으로  안에 argument를 넣어서 만들면 vertex shader과 fragment shader를 구분할 수 있게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">GLuint shader <span class=\"token operator\">=</span> <span class=\"token function\">glCreatorShader</span><span class=\"token punctuation\">(</span>GL_VERTEX_SHADER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glShaderSource</span><span class=\"token punctuation\">(</span>shader<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>source<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glCompileShader</span><span class=\"token punctuation\">(</span>shader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>GLuint = GL unsigned integer type</p>\n</li>\n<li>\n<p>shader object에 실제로 shader코드를 저장하는 것 <code class=\"language-text\">glShaderSource</code>, <code class=\"language-text\">&amp;source</code>를 통해 소스코드를 저장할 수 있다.</p>\n</li>\n<li>\n<p>glCompileShader를 통해 compile 할 수 있다.</p>\n</li>\n</ul>\n<h3 id=\"program-object\" style=\"position:relative;\"><a href=\"#program-object\" aria-label=\"program object permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Program Object</h3>\n<ul>\n<li>vertex shader와 fragment shader가 만들어진 후에, 이 둘을 붙여서 program object라는 걸로 통합을 해야한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">GLuint program <span class=\"token operator\">=</span> <span class=\"token function\">glCreateProgram</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glAttachShader</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">,</span> shader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//glAttachShader(program, fragment_shader);</span>\n<span class=\"token function\">glLinkProgram</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glUseProgram</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>해당 프로그램에다가 <code class=\"language-text\">vertex shader</code>object를 붙여야 하기 때문에 <code class=\"language-text\">glAttachShader</code>함수를 이용한다.</li>\n<li>연결해주기 <code class=\"language-text\">glLinkProgram</code></li>\n<li>사용하기 <code class=\"language-text\">glUseProgram</code></li>\n</ul>\n<h3 id=\"attributes\" style=\"position:relative;\"><a href=\"#attributes\" aria-label=\"attributes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Attributes</h3>\n<p>Polygon Mesh의 데이터들을  <code class=\"language-text\">.obj</code>파일을 통해 vertex array와 index array를 import해올 것이다.</p>\n<ul>\n<li>각각을 가리키는 pointer들을 <code class=\"language-text\">vertices</code>와 <code class=\"language-text\">indices</code>로 설정해보자.</li>\n<li>각각을 <code class=\"language-text\">objData</code>라는 구조체에 모아져 있다고 해보자.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Vertex</span> <span class=\"token punctuation\">{</span>\n    glm<span class=\"token operator\">::</span>vec3 pos<span class=\"token punctuation\">;</span> <span class=\"token comment\">// position</span>\n    glm<span class=\"token operator\">::</span>vec3 nor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// normal</span>\n    glm<span class=\"token operator\">::</span>vec2 tex<span class=\"token punctuation\">;</span> <span class=\"token comment\">// texture coordinates</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">typedef</span> GLushort Index<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">ObjData</span> <span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>Vertex<span class=\"token operator\">></span> vertices<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>Index<span class=\"token operator\">></span> indices<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nObjdata objdata<span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">glm</code>는 OpenGL Mathematics를 의미하는데 유용한 유틸리티이다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 18.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsUlEQVQY042Q2Q6EIAxF/f8vBOOWCCKgwGjclztpk3kfkhNe7tI26/seWmssy4J/3vu+uK4L+77Dew+lFP/HcTBZURQg6rrGPM+47xvTNKHrOoYMVHqeJ57nQUoJWik46yCFQJ7nEELAdIb1GRmMMdySYuTQtm0hpURZlqiqigtpCwr9pARrLXtIRzRNA+ccl2UxRhAhBB6ZJqRQgs7wY11XXnnbNgx+YP3PR4zjiBgCvmn7LwzZqwzDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"residing\"\n        title=\"residing\"\n        src=\"/static/ed1df13edd3a2de10988fa19ab553ec7/37523/residing.png\"\n        srcset=\"/static/ed1df13edd3a2de10988fa19ab553ec7/e9ff0/residing.png 180w,\n/static/ed1df13edd3a2de10988fa19ab553ec7/f21e7/residing.png 360w,\n/static/ed1df13edd3a2de10988fa19ab553ec7/37523/residing.png 720w,\n/static/ed1df13edd3a2de10988fa19ab553ec7/302a4/residing.png 1080w,\n/static/ed1df13edd3a2de10988fa19ab553ec7/07a9c/residing.png 1440w,\n/static/ed1df13edd3a2de10988fa19ab553ec7/6f175/residing.png 2036w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>메모리에 vertex array랑 index array가 로드가 된 것인데, 이를 실제로 렌더링을 진행할 GPU로 옮겨주어야 하는데, 이를 <strong>GPU 메모리에 buffer object를 만든다고 표현한다.</strong></p>\n<ul>\n<li>Vertex array → array buffer object</li>\n<li>Index array → element array buffer object</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">GLuint abo<span class=\"token punctuation\">;</span>\n<span class=\"token function\">glGenBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>abo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> abo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> \n    <span class=\"token punctuation\">(</span>GLsizei<span class=\"token punctuation\">)</span> objData<span class=\"token punctuation\">.</span>vertices<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    objData<span class=\"token punctuation\">.</span>vertices<span class=\"token punctuation\">.</span><span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>Buffer를 생성해서 기존 vertex array를 연결해주고, 해당 데이터를 박아 넣는 느낌으로 이해하면 되겠다.</li>\n</ul>\n<p><strong>index array도 동일하게 진행된다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 11.666666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAZklEQVQI1y2MSQrEMBAD8/+XBoy3dIjTi6khzRxECVHoWGtRa2WMkey901pDRJK5907/2BpmRkSkN/5uplbmnBzxvvhaqAgugl4Xft/48+Bm6MfzREvBSyH2zsNwz3NVxb+uxo7gB4GMmjgOw79CAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bufferObject\"\n        title=\"bufferObject\"\n        src=\"/static/a7aa0a56779bdedd221c4612ab253cc4/37523/bufferObject.png\"\n        srcset=\"/static/a7aa0a56779bdedd221c4612ab253cc4/e9ff0/bufferObject.png 180w,\n/static/a7aa0a56779bdedd221c4612ab253cc4/f21e7/bufferObject.png 360w,\n/static/a7aa0a56779bdedd221c4612ab253cc4/37523/bufferObject.png 720w,\n/static/a7aa0a56779bdedd221c4612ab253cc4/302a4/bufferObject.png 1080w,\n/static/a7aa0a56779bdedd221c4612ab253cc4/07a9c/bufferObject.png 1440w,\n/static/a7aa0a56779bdedd221c4612ab253cc4/8170e/bufferObject.png 2132w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// position = attribute 0</span>\n<span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> GLvoid<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">,</span> pos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// position = attribute 1</span>\n<span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> GLvoid<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">,</span> nor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// position = attribute 2</span>\n<span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> GLvoid<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">,</span> tex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>시작점을 알려주는 것이 굉장히 중요해 보인다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">glEnableVertexAttribArray</code> Vertex array 데이터를 활성화 시키겠다는 것이다.</p>\n</li>\n<li>\n<p>Vertex Shader에서 location 0, 1, 2에 position, normal, texCoord를 할당시켰던걸 기억해야한다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">3, GL_FLOAT</code> → 3차원 원소이면서, 각 원소는 float형태이다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">sizeof(Vertex)</code> = stride</p>\n</li>\n<li>\n<p><code class=\"language-text\">offsetof()</code> → 시작지점을 알려주는 함수</p>\n</li>\n</ul>\n<br/>\n<h3 id=\"uniform\" style=\"position:relative;\"><a href=\"#uniform\" aria-label=\"uniform permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Uniform</h3>\n<p>Our vertex shader has three uniforms: <code class=\"language-text\">worldMat</code>, <code class=\"language-text\">viewMat</code>, and <code class=\"language-text\">projMat</code>.</p>\n<ul>\n<li>매 씬마다 world matrix는 변동될 것이다.</li>\n<li>카메라가 움직인다고 생각해봐도 view matrix는 계속 변동될 것임을 알 수 있다.</li>\n<li>projection matrix는 4가지 파라미터, fovy, aspect, n, f 이것들이 변하지 않은 이상 변화는 없을 것이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">glm<span class=\"token operator\">::</span>mat4 worldMatrix<span class=\"token punctuation\">;</span> <span class=\"token comment\">// repeatedly updated for a dynamic object</span>\n\nGLint loc <span class=\"token operator\">=</span> <span class=\"token function\">glGetUniformLocation</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">,</span> <span class=\"token string\">\"worldMat\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">glUniformMatrix4fv</span><span class=\"token punctuation\">(</span>loc<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">value_ptr</span><span class=\"token punctuation\">(</span>worldMatrix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p><code class=\"language-text\">glGetUniformLocation</code> 프로그램 오브젝트 world 행렬의 위치를 찾아낼 수 있다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">worldMat</code>과 <code class=\"language-text\">worldMatrix</code>는 다르다. worldMat은 shader가 갖고 있는 변수이고, worldMatrix는 openGL ES가 갖고 있는 변수가 되겠다.</p>\n</li>\n<li>\n<p>위치를 확인한 그 변수를 shader variable 자리에 넣어주면 된다.</p>\n</li>\n</ul>\n<br/>\n<h3 id=\"drawcalls\" style=\"position:relative;\"><a href=\"#drawcalls\" aria-label=\"drawcalls permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Drawcalls</h3>\n<p>모든게 마무리 되면 이제 그리기만 하면 되겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">144</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>index array없이도 이런식으로 호출이 가능하다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">glDrawElement</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">144</span><span class=\"token punctuation\">,</span> GL_UNSIGNED_SHORT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n</code></pre></div>\n<ul>\n<li>element = 결국 index라는 점을 인지해야겠다.</li>\n</ul>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#gpu-rendering-pipeline-all-transforms\">GPU Rendering Pipeline, All Transforms</a></p>\n</li>\n<li>\n<p><a href=\"#vertex-and-index-arrays\">Vertex and Index Arrays</a></p>\n</li>\n<li>\n<p><a href=\"#opengl-es\">OpenGL ES</a></p>\n<ul>\n<li><a href=\"#opengl-es-shading-languageglsl\">OpenGL ES Shading Language(GLSL)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#vertex-shader\">Vertex Shader</a></p>\n</li>\n<li>\n<p><a href=\"#gl-programgl-api\">GL Program(GL API)</a></p>\n<ul>\n<li><a href=\"#program-object\">Program Object</a></li>\n<li><a href=\"#attributes\">Attributes</a></li>\n<li><a href=\"#uniform\">Uniform</a></li>\n<li><a href=\"#drawcalls\">Drawcalls</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"ⓒ 2019. JungHyun Han Korea University Seoul, All rights reserved. GPU Rendering Pipeline, All Transforms  물체가 n개라면 n번의 world transform이 일어날 것이다. Vertex and Index Arrays  texture coordinate라는 좌표도 vertex array에 각 셀에 같이 입력되는데, position, normal과 함께 필수 요소라고 볼 수 있다. GPU는 parallel 프로세서이기 때문에 각 vertex들이 병렬적으로 처리될 수 있다. OpenGL ES Vertex Shader와 Fragment Shader는 결국 프로그램이기 때문에, 각자가 스스로 API에게 제공을 해야 시스템이 돌아간다. Shader를 짜기 위한 GPU에 특화된 언어를 사용해야하는데, 이를 OpenGL ES Shading Language라고 한다.(GLSL) OpenGL ES Shading L…","frontmatter":{"date":"September 27, 2024","title":"OpenGL ES 3차원 컴퓨터그래픽스 GL & Shader","categories":"OpenGL","author":"ALEX","emoji":"🥽"},"fields":{"slug":"/opengl-es-shader/"}},"next":{"id":"3e43c37b-8233-5692-a5ad-61ebe96f9090","html":"<p>ⓒ 2019. <a href=\"https://media.korea.ac.kr/people/jhan/\">JungHyun Han</a> Korea University Seoul, All rights reserved.</p>\n<br/>\n<h2 id=\"gpu-rendering-pipeline\" style=\"position:relative;\"><a href=\"#gpu-rendering-pipeline\" aria-label=\"gpu rendering pipeline permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GPU Rendering Pipeline</h2>\n<p>GPU 렌더링은 다양한 과정을 걸쳐서 나타나는데,</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA/UlEQVQY012OvUrDYBhGcyOuXomb4OQVOLg46uINOLiK4OIfii6FgoNUKo1ZFMWSplWItRKrbUy0knyJJV8C/Y4kzSAeeN6f5eFoSinyUO48E6WQaUoYBMSRIMtSLMviudcjx2hUuTg/LW6lJmVU8WuUKP6QScT3F/FYEsQpzpuHabb4dAfYHZPDgy3qVw3+k5dq+RBRxMjzUTKh7Ql2mn30QYIcXjO62WDc2kaELkdtl5MHD/njI+42yT7u0Y09VldmcZzXqWFemEhJHIaFmd4PWao02X2MSbpV/MoiorbMcGCzVnti/fIF/71Dd3+e2D7j1jhmYW6GujE1/gU1bCDEZ1dFzwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"rendering\"\n        title=\"rendering\"\n        src=\"/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/37523/rendering.png\"\n        srcset=\"/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/e9ff0/rendering.png 180w,\n/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/f21e7/rendering.png 360w,\n/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/37523/rendering.png 720w,\n/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/302a4/rendering.png 1080w,\n/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/07a9c/rendering.png 1440w,\n/static/fcbc6eb41dd6d6e7ff3d7ace01132f88/8c48a/rendering.png 2096w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>\n<p>polygon mesh가 GPU안으로 입력되면, polygon mesh의 정점들은 vertex array에 저장이 되어 있을 것이다.</p>\n</li>\n<li>\n<p>해당 정점들을 vertex shader가 한번에 하나씩 불러들이면서 연산을 하기 시작함.</p>\n</li>\n<li>\n<p>rasterizer를 통해 index array에 있는 정보를 바탕으로 삼각형을 조립하기 시작. 조립된 삼각형은 화면 안에서 여러개의 픽셀을 품고 있을텐데, 이때 각각의 픽셀의 색상을 결정할 정보를 rasterizer가 모아서 각 픽셀 위치마다 저장을 해놓는다.(= fragment)</p>\n</li>\n<li>\n<p>fragment shader를 통해서 각 fragment의 색깔을 결정한다.</p>\n</li>\n<li>\n<p>마지막으로, output merger가 결정된 색상을 보여줄 건지, 말건지를 결정해서 최종 스크린에 뿌려주게 된다.</p>\n</li>\n</ol>\n<p>이 모든 일련의 과정을 <strong>GPU Rendering Pipeline</strong>이라고 한다.</p>\n<br/>\n<blockquote>\n<p>특히, 이 과정에서 등장하는 shader라는 것은 곧, 프로그램을 의미하기 때문에 프로그램을 짜주어야 한다.\n반면에, rasterizer나 output merger는 하드웨어 그 자체이기 때문에, 정해진 것만 실행하는 역할을 한다고 생각하면 될 것 같다.</p>\n</blockquote>\n<br/>\n<h2 id=\"vertex-shader\" style=\"position:relative;\"><a href=\"#vertex-shader\" aria-label=\"vertex shader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Vertex Shader</h2>\n<p>vertex shader가 작동될 때는, object space에 있는 물체를 clip space로 전환하는 과정이 일어난다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 13.333333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAxElEQVQI1z3KzWrCQABF4TxttTQu6q59GqtRKn0Bd64FhXZhFTt1EtJoaycZDNL8zDhHCMXFgcvH9bTNyEyKwaB+FYefQ7O1TZvsv+d5Tk1FZhTHs+ZUnJBb2fxLCvQ55eg0Xmfnc5u0Wdg5sYiJPiJm9YzO3sf/vmNZLwk3IfFnzNRMaUU3dNU9ohCIlSCRCRM3of3V4jF/wAuqEU9VgCQES9PWSQblkEE9ZOf2V393a/plwMg8o1x69Vf3Ru+vz9i8cAEBWNYJDjJCagAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"vertexshader\"\n        title=\"vertexshader\"\n        src=\"/static/e7ac1e6f6174cf2df2f27ece7f4f539f/37523/vertexshader.png\"\n        srcset=\"/static/e7ac1e6f6174cf2df2f27ece7f4f539f/e9ff0/vertexshader.png 180w,\n/static/e7ac1e6f6174cf2df2f27ece7f4f539f/f21e7/vertexshader.png 360w,\n/static/e7ac1e6f6174cf2df2f27ece7f4f539f/37523/vertexshader.png 720w,\n/static/e7ac1e6f6174cf2df2f27ece7f4f539f/302a4/vertexshader.png 1080w,\n/static/e7ac1e6f6174cf2df2f27ece7f4f539f/07a9c/vertexshader.png 1440w,\n/static/e7ac1e6f6174cf2df2f27ece7f4f539f/3126c/vertexshader.png 1876w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>OS → WS 과정은 앞에서 배운 것과 동일하다.</em></p>\n<p>다만, 우리가 배운 transform의 과정에서 normal에 대한 transform은 배우지 않았는데,</p>\n<ul>\n<li>scaling, translation, rotation과 같은 affine 변환을 거친 후에 normal 벡터는, 결국 모든 과정을 거친 행렬을 [L|t] 라고 정의했을 때, <code class=\"language-text\">Ln + t</code>의 공식을 적용할 수 있고, 이때 <code class=\"language-text\">+ t</code> 부분은 아무런 영향을 주지 않기 때문에, <code class=\"language-text\">Ln</code>으로 normal 들이 바뀐다는 것이다.</li>\n</ul>\n<p><strong>만약 non-uniform scaling이라면?</strong></p>\n<p>이 때는 L의 <code class=\"language-text\">역행렬 연산</code> 후 <code class=\"language-text\">전치행렬 처리</code>를 해주면 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABFElEQVQY002QbUvEMBCE+/9/lOCJIOcHFZEetke1pRWbbtKXS9okbUeyEr2BYUPYfTLZZN93uG1j+31nB+1X9dpR27ZhXVcopaC1hjEGzjkko3N4LEs8NQ2OH5+4P5/RKMVDodE7h2sty4JpmtD3PbtpGkgp+c5ai0RZi7ssw3N6wu05OEdFMkQDtQKGBAYzgTpiQEwW0oTati0ulwuICPM8I+mtxUNZ4qWq8FZkeKUOrdYgIaD6AVp8YxwljJk5cVSABXj4angorocT3qQpDnmOY5bjkJ5QDwM3dJLwVdfQUkEbw5C4v6qqUBQFJ+y67h9ovEdGhHchkEmJtBUYl4UbnPe/u3EW3nsGxcF4DumEEH/AH10wy/+7wgweAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"inversetranspose\"\n        title=\"inversetranspose\"\n        src=\"/static/17de61508a96faab4cebac5a811b0cf8/37523/inversetranspose.png\"\n        srcset=\"/static/17de61508a96faab4cebac5a811b0cf8/e9ff0/inversetranspose.png 180w,\n/static/17de61508a96faab4cebac5a811b0cf8/f21e7/inversetranspose.png 360w,\n/static/17de61508a96faab4cebac5a811b0cf8/37523/inversetranspose.png 720w,\n/static/17de61508a96faab4cebac5a811b0cf8/302a4/inversetranspose.png 1080w,\n/static/17de61508a96faab4cebac5a811b0cf8/07a9c/inversetranspose.png 1440w,\n/static/17de61508a96faab4cebac5a811b0cf8/0ff19/inversetranspose.png 2084w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>즉, vertex에 L을 적용할 때, triangle normal에는 L의 <code class=\"language-text\">역행렬 연산</code> 후 <code class=\"language-text\">전치행렬 처리</code>를 적용해야 한다.</li>\n<li>정점 포지션과, 정점 Normal은 서로 다른 변화에 의해 다른 적용을 연산받아야 한다는 점을 알 수 있다.</li>\n</ul>\n<p><strong>uniform-scaling과 rotation</strong></p>\n<p>여기서는 마찬가지로 동일하게 L을 적용하면 되는데, 위의 경우와 마찬가지로 L의 <code class=\"language-text\">역행렬 연산</code> 후 <code class=\"language-text\">전치행렬 처리</code>를 적용해도 같은 값이 나오므로 헷갈리지 말고 그냥 동일하게,</p>\n<p>L의 <code class=\"language-text\">역행렬 연산</code> 후 <code class=\"language-text\">전치행렬 처리</code> 로 외우면 될 것 같다.</p>\n<blockquote>\n<p>지금까지는 triangle normal을 기준으로 살펴보았는데, 사실 알고보면 vertex array에 들어가 있는 것은 vertex normal들이기 때문에 vertex normal에 대한 내용을 알아야 한다.</p>\n</blockquote>\n<br/>\n<h3 id=\"camera-space\" style=\"position:relative;\"><a href=\"#camera-space\" aria-label=\"camera space permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Camera Space</h3>\n<ul>\n<li>\n<p>AT : 내가 기준으로 삼는 3차원 좌표를 AT이라고 한다.</p>\n</li>\n<li>\n<p>EYE : 어디를 찍겠다는 것을 그냥 EYE라고 칭한다.</p>\n</li>\n<li>\n<p>UP : 카메라의 기울기를 정의할 수 있는 카메라의 법선벡터를 UP이라고 정의한다.</p>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABOUlEQVQoz31SXWvCMBTt//8xwh6EjT3sWdnWqcMKioNujTUNaWI/bZOekWhrq+KBEC735txz7o2DKzRNY+8kOZgIp7AZ5LTWOB6PUEpBHiSKoujyTr+w/2A6naMsK9zLV1UFzjk4Y1guvvEb7G4J29PCfV+AMY7rfL/G4MBjRJReCLuC9tIaZVmeCzQeobXaV28V1vXJmrda4Xk8Rp6mqOvaEptH5jYzM6NQWiEWEk+jEf58/yyiGVre8z0oI/C+Zlh6XtedUorNZgNCiCU1JxQEZLvFZDKxTa9nbAk/Zy7eXl7RVJclGEWMMazXayRJYjcahiHc+QfSWN5YHViOogg/PkHIM2vLwKgRQiAIgm4ZJt7tKPxQIM2KwcJaOP0hGzKt23+YQEqJPM+t2iw7NVOqtsrjWNwl/AeadbsjYk40mQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"camera\"\n        title=\"camera\"\n        src=\"/static/b363c19aef2b22ac0171fea6b856143f/37523/camera.png\"\n        srcset=\"/static/b363c19aef2b22ac0171fea6b856143f/e9ff0/camera.png 180w,\n/static/b363c19aef2b22ac0171fea6b856143f/f21e7/camera.png 360w,\n/static/b363c19aef2b22ac0171fea6b856143f/37523/camera.png 720w,\n/static/b363c19aef2b22ac0171fea6b856143f/302a4/camera.png 1080w,\n/static/b363c19aef2b22ac0171fea6b856143f/07a9c/camera.png 1440w,\n/static/b363c19aef2b22ac0171fea6b856143f/0ef7e/camera.png 1594w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>해당 공식을 통해, {u, v, n}은 모두 수직인 관계임을 알 수 있고, 이는 orthonormal하다고 볼 수 있다. 거기에 EYE가 원점 역할을 하기 때문에 완벽한 3차원 좌표계를 구성한다고 볼 수 있다.</p>\n<ul>\n<li>이때 cross product한 값을 normalize를 하지 않은 이유는, 두 벡터가 이루는 평행사변형의 넓이가 cross product의 값이 되는데 이때 단위벡터 두개가 90도를 이루기 때문에, 넓이 또한 1이 될 수 밖에 없기에 굳이 하지 않아도 되는 것이다.</li>\n</ul>\n<h2 id=\"view-transform\" style=\"position:relative;\"><a href=\"#view-transform\" aria-label=\"view transform permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>View Transform</h2>\n<p>가장 주된 목표는, 월드 공간에서 카메라 공간으로의 변환이 가장 큰 목표가 될 것 같다.</p>\n<ul>\n<li>1단계. 원점 맞춰기 (eye = O)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABI0lEQVQoz3VR3W6DIBj1/d9m3rTZfW+2e82S2apTJq6C1U5BgbNgpsXaHmIAge87Px4cGGOWef4smqZBGIa4h3tnXnvPDtx/bdsiTVPEcYycEGhjoJTaELHwHjF8xiIIArzudrhUFXopoO3QevXWu2c1jgq0JCi+s+nC8XQEY2xpoMYRV16j5RzR8QNd163ee65Ui14IkCwDY/W0H4ZhkTfz7/seJaVg7AIp5couzy1m6fOqwrWuIaR8KF87Fjgnt4KuR0VRwPf9KQQhxM1DrTEYA/YZgb/4qA4HJFkOzjnO5wpFQdcMLZIkASFkk97UzBj8ComfKALf78He3pFmORjjoJTiK8uhRjXxXCTbgmVZbpK1clxLbKZK66mxDVD/r2eGfwChvWbhaNLjAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"chapter\"\n        title=\"chapter\"\n        src=\"/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/37523/chapter.png\"\n        srcset=\"/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/e9ff0/chapter.png 180w,\n/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/f21e7/chapter.png 360w,\n/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/37523/chapter.png 720w,\n/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/302a4/chapter.png 1080w,\n/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/07a9c/chapter.png 1440w,\n/static/7f1d79cb4a31ee7c8a89e5ae27208ccb/82747/chapter.png 2232w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>월드공간 = 카메라 공간을 맞추는 과정에서, 이전에 배웠던 rotation에서 배웠던 e1, e2, e3 벡터와 맞춰지는 공식을 넣어서 생각해볼 수 있을 꺼 같다.</li>\n</ul>\n<p>(<strong>space change = translation + basis change</strong>)</p>\n<ul>\n<li>결론</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAv0lEQVQY032P2U7DMBBF+/8fB4WXShWlpFkcx45jZ7WV5SCbSjzBSDMPI93lnI7j4K/pbIfrHf0wYJ1FaYU2Bt0qjLXcbh98Znesc2zbljSnePZ9x3QG731a2dT4ECirIpk0WmGM5lEWXK4XhKxodMv57YXX93P6hxB+DWPL2KAfepZlSc3WdSUvcoQUCFkjlaQUVTIsRUnbdXxld7L8QVULfPA/hv8hu2fIOI4JK+JHkkY1TPOcQqN+mifWJ/I3o5QyPGvFZGkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"matrix\"\n        title=\"matrix\"\n        src=\"/static/d14217f8b41f9b0293fde8e53b1e542f/37523/matrix.png\"\n        srcset=\"/static/d14217f8b41f9b0293fde8e53b1e542f/e9ff0/matrix.png 180w,\n/static/d14217f8b41f9b0293fde8e53b1e542f/f21e7/matrix.png 360w,\n/static/d14217f8b41f9b0293fde8e53b1e542f/37523/matrix.png 720w,\n/static/d14217f8b41f9b0293fde8e53b1e542f/302a4/matrix.png 1080w,\n/static/d14217f8b41f9b0293fde8e53b1e542f/58354/matrix.png 1396w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n우리가 원했던 카메라 좌표계의 좌표였는데 이미 두 좌표가 동일하게 된 상태이므로 그냥 월드좌표를 그대로 따오면 될 꺼 같다.</p>\n<p>Mview  is applied to all objects in the world space to transform them into the camera space</p>\n<ul>\n<li>이런 space/basis change는 컴퓨터 그래픽스나 컴퓨터 비전, 증강현실, 로보틱스 모든 분야에 정말 중요한 역할을 한다. (3차원을 다루는 모든 분야)</li>\n</ul>\n<br/>\n<h3 id=\"right-hand-vs-left-hand\" style=\"position:relative;\"><a href=\"#right-hand-vs-left-hand\" aria-label=\"right hand vs left hand permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Right-hand vs Left-hand</h3>\n<p>RHS 좌표계에서 정의된 것을 LHS로 좌표계를 옮기게 된다면, 이는 다른 현상을 보일 것이다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABwElEQVQoz2WSTY/TMBCG+++RuHHkwJ0DHBAXQAKBFgm0LIXtBSQuFS1t2qVJ7KT+th9kt65adqQoHicz837MBCCllF947+m6nhr13lqL6AXnkWLEeV9qQginfyf5UJP84e7vlvWiwQl5KlZaMaqxnNu2RQhRBhsl0VbRSUnfd4eG50hICekls09zNi9f4WMghoj2ik27pWk2rNdr+l7gzcDNHGYPnpBePEOECDFeIhSj5c+qwcieYZBY58r9atvz5XqG2DRHJpFRtnz+ofj+/Ap3+5V23FeEuSFYF0vDjCgYUzTKEWNESIV3nuh9yctwIbFaYvH0WjMO8pJyZa2UIh6TitxZi5TynlmHienCrBPl+ggpTihq4QGlKBrXu0FKpHWYvB1moBeHugn/xW6/w4VE1jgX1+a7fUvFEpyjMxb//i0/Hz5mugA99GhjDgiz+GpvspAsm4a75Zrg/HE3Hb8XK64+TlFdRwwBawyt0vDtmumjp7y59Tgt0dowKY6pkZsPv9i9foc7muKMKYOWy2VZF6UMwZqiZ44xU3aevAfRZcryknKMif0wFFPqks/n85KnFLHW3DMlb0L0gXBmzD+qtVR6GYJ+SgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"RHSLHS\"\n        title=\"RHSLHS\"\n        src=\"/static/27f8be9a12edbbfd0ba5bef7f9725280/37523/RHSLHS.png\"\n        srcset=\"/static/27f8be9a12edbbfd0ba5bef7f9725280/e9ff0/RHSLHS.png 180w,\n/static/27f8be9a12edbbfd0ba5bef7f9725280/f21e7/RHSLHS.png 360w,\n/static/27f8be9a12edbbfd0ba5bef7f9725280/37523/RHSLHS.png 720w,\n/static/27f8be9a12edbbfd0ba5bef7f9725280/302a4/RHSLHS.png 1080w,\n/static/27f8be9a12edbbfd0ba5bef7f9725280/07a9c/RHSLHS.png 1440w,\n/static/27f8be9a12edbbfd0ba5bef7f9725280/cc418/RHSLHS.png 1992w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>사실 z좌표 부호만 바꿔주면, 모두 해결되는 것이다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABuUlEQVQoz2WTP5PTMBDF71szNAyfgoahouRaakq6AzIEhhxMyF3OieMkjiXL+q8fIzsxvsk2krzat0/vrW8AUkp54Xis6VTb79Pk+36/x1rLJWKMaK3R2mCcw1g73r3Jm8uhM5J1sePxywJMN4JKLfq8EIKiKPq1EQ1OS1RZcsgNnRsApwxb07A5Ku4/fqZb/sENdFhXBavVA1VVIaVEK0HVJt6/nWFevqDdbrEh/GeYw7jIuqyR1Q6rFcZ7UooYF/g2X/L0e0kwur+rWklR1tx93SLncw67sn/2yDDEhNI+kxk0OnfLoY3DOT9ql8N7T9e1pGTpYkQpNeaePdkYg/cD2KAto3burNE0+vyFxbnmmSlZn1NdE4hMG2XAdC5s27ZvLLIpriPPxEkIgvfXDLUT/N3UfP/wCTbr3uUYIsI2SNWyLcvB5aZBKM2vnxXd7S31+qnX/GpsDqLmcVWwW6xoyi2hZ5X4cb9kdjdDNU3fRMmG3cnw5t2C46vXiIcVZqphjAnrEtp4bNvine0LGQdeok6CcHay6zqOhwPOKSRQTQZ/dDmDPhd8OIcQsNZc/T0XIkwmIpvyD2lzVI2oBdiBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"znegotion\"\n        title=\"znegotion\"\n        src=\"/static/48f195b987316eef8d76b4f28b375631/37523/znegotion.png\"\n        srcset=\"/static/48f195b987316eef8d76b4f28b375631/e9ff0/znegotion.png 180w,\n/static/48f195b987316eef8d76b4f28b375631/f21e7/znegotion.png 360w,\n/static/48f195b987316eef8d76b4f28b375631/37523/znegotion.png 720w,\n/static/48f195b987316eef8d76b4f28b375631/302a4/znegotion.png 1080w,\n/static/48f195b987316eef8d76b4f28b375631/07a9c/znegotion.png 1440w,\n/static/48f195b987316eef8d76b4f28b375631/263f4/znegotion.png 1996w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<br/>\n<h2 id=\"view-frustum\" style=\"position:relative;\"><a href=\"#view-frustum\" aria-label=\"view frustum permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>View Frustum</h2>\n<p>world space상에서의 x,y,z 축은 이제 의미가 없어진다. u,v,n으로 정의된 축을 바탕으로 카메라가 어느 정도의 공간을 잡아낼 것인지를 결정해야겠다.</p>\n<ul>\n<li>4가지 parameter로 결정하는데, fovy(field-of-view-yaxis/시야각), fovx, apsect(종횡비)등등이 있겠다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAABAklEQVQY002QzW7CMBCE8/6vQJ8FiVPhUJBQCsVpKwIioSGJiEOcpP75KhsqMdZcPDs7uxvxQN/3jMPAmOc4KenHX5Tqw3/btozjSFVVNFLSFQVlHGOkvJudC/Qv8oY0TVFK0XUd8nymPZ1Qg6EbFMbph8cxm82YTqcsl0u+12sysQuaNjronpFPF0KEhvP5HJEkGGf5uVxJs4xrp7DGBmOe52y3WyaTFxaLV76SD/bpnrzOwN1rIp5Q13Uw+Ulvt46+H9HaYK0LelmWHI9HdkKwidd8JoJ4885q9UZVSrSxRP+j+tU9tdZYa59zgu7hb3g4HCiKC03ThK2MMUG7qXv4H7T7fFp9aQSIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4parameter\"\n        title=\"4parameter\"\n        src=\"/static/4f093c9d7dcb5d6cc745c293778e71ad/37523/4parameter.png\"\n        srcset=\"/static/4f093c9d7dcb5d6cc745c293778e71ad/e9ff0/4parameter.png 180w,\n/static/4f093c9d7dcb5d6cc745c293778e71ad/f21e7/4parameter.png 360w,\n/static/4f093c9d7dcb5d6cc745c293778e71ad/37523/4parameter.png 720w,\n/static/4f093c9d7dcb5d6cc745c293778e71ad/302a4/4parameter.png 1080w,\n/static/4f093c9d7dcb5d6cc745c293778e71ad/07a9c/4parameter.png 1440w,\n/static/4f093c9d7dcb5d6cc745c293778e71ad/3145a/4parameter.png 2112w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>실린더 모형의 경우는 시야각 밖에 있기 때문에 구현되지 않는다.</em></p>\n<ul>\n<li>그래픽스 렌더링에서는 시야각의 앞과 뒤를 일부 잘라내서 표현하는데, n과 f의 파라미터는 near plane과 far plane을 의미한다. 모든 물체들은 음의 z축에 있기 때문에, -n과 -f가 되겠다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABIUlEQVQY012RT2vCMByG+9132WXfZOyww9xwjHkcO4ijooKgs0NoTZsmbfonbfqMVu3BHySE8PK+b5543I5zl0M37FVVYYzBWjtK6jzDpulZ1XXj6sfrLiau66jKkmK3o41jMlNSGEPZ3xUFtbUE6xV/2y1FmhLN5xTH4yW7G/J7U69RChsEVMbwu98jo4hMCPLSkRZqbGWbhmDps1ss+JzN2Cx9/O8vcq2pW4ttm3PDpn9OEpOnmo/XKbvDHpMVnCKFzDPSrMI5N6RLKUmlZPIy4X36xsP9HZvVGqFCtJZnw5FLXSNigVYKrTVt244sr3yEECRJgohjVv4Pz0+Pg1acBIfgRGVbvKu4b9GzcuOnXIEzGvZmYRiilBrY3k7nHP+Xs8uNEofVNgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nfparameter\"\n        title=\"nfparameter\"\n        src=\"/static/6a13ae0ae8bc1ac7a27f6d85a369105b/37523/nfparameter.png\"\n        srcset=\"/static/6a13ae0ae8bc1ac7a27f6d85a369105b/e9ff0/nfparameter.png 180w,\n/static/6a13ae0ae8bc1ac7a27f6d85a369105b/f21e7/nfparameter.png 360w,\n/static/6a13ae0ae8bc1ac7a27f6d85a369105b/37523/nfparameter.png 720w,\n/static/6a13ae0ae8bc1ac7a27f6d85a369105b/302a4/nfparameter.png 1080w,\n/static/6a13ae0ae8bc1ac7a27f6d85a369105b/07a9c/nfparameter.png 1440w,\n/static/6a13ae0ae8bc1ac7a27f6d85a369105b/f60cd/nfparameter.png 2318w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>truncated pyramid</em></p>\n<ul>\n<li>이렇게 잘린 피라미드 모형의 시야각 외의 물체들은 내가 안보겠다, 라고 선언한 것과 (처리하지 않겠다.) 동일하게 볼 수 있을 것 같다.</li>\n</ul>\n<h3 id=\"view-frustum-culling\" style=\"position:relative;\"><a href=\"#view-frustum-culling\" aria-label=\"view frustum culling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>View Frustum Culling</h3>\n<p>위에서 언급했듯이 머리 잘린 피라미드 (view-frustum)안에 들어와있는 object들 제외하고, 나머지 물체들을 무시하여 렌더링 제외시키는 것을 의미한다.</p>\n<p><strong>Clipping</strong></p>\n<p>view frustum 안에 있는 object이더라도, 어느 부분은 경계선에 닿아 구현되지 않는 부위가 생길 수 있다. 해당 부위를 잘라내는 행위를 우리는 clipping이라고 한다.</p>\n<ul>\n<li>하지만, 현재 view frustum의 형태처럼 비스듬히 있는 모형은 정확하게 잘라서 규정하기 어려운 부분이 있다.</li>\n</ul>\n<br/>\n<h2 id=\"projection-transform\" style=\"position:relative;\"><a href=\"#projection-transform\" aria-label=\"projection transform permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Projection Transform</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABP0lEQVQoz22Sb4vCMAzG9829L+Zr8d4IOzw8YTonzrJ/um6z69r0ORrdUDEQaNP0l/RJAzyMiGCtZffmnHvxMfae62PkHOrrFV3XISiKAnEcI01Tdr/2B8+AEeoBWmsGKqUgCgFrCcZaDEqBjEFwPB6x2WywDkN8L5cQQqCqKrRtyzDVqwnMcCJcygqyaSCuAvTocswJ8izjzsLVCl+zGebzOe/3+z2MNTjLlBN9gbHI+XRCURbYxRGS+ATVDyC6SxWUZQnfZZIkWCwWCMMQf9stDocDLvKC3/UPmrqDbFq0TfPoume41gO6W4+ykpP2gX9eFEUMzLIMeZ5zh33fs1ZStkhzicEQX3gehnMEaww/ewKyuEJASjkJ/sl8XlvX0Lcb5zwPbCzAwE+X378MkcNgDAateSj3GLEbY16+2j8XvGkhuH6VngAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"projectTransform\"\n        title=\"projectTransform\"\n        src=\"/static/09d5151ca79b2dd617223a6c3b415f72/37523/projectTransform.png\"\n        srcset=\"/static/09d5151ca79b2dd617223a6c3b415f72/e9ff0/projectTransform.png 180w,\n/static/09d5151ca79b2dd617223a6c3b415f72/f21e7/projectTransform.png 360w,\n/static/09d5151ca79b2dd617223a6c3b415f72/37523/projectTransform.png 720w,\n/static/09d5151ca79b2dd617223a6c3b415f72/302a4/projectTransform.png 1080w,\n/static/09d5151ca79b2dd617223a6c3b415f72/07a9c/projectTransform.png 1440w,\n/static/09d5151ca79b2dd617223a6c3b415f72/7ef4c/projectTransform.png 1748w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>정육면체로 공간을 조정하면, 변환 자체는 안에 있는 object들에게 모두 적용되어야 할 것이다. 이렇게 정육면체로 조정되면 clipping하기 매우 편할 것이다.</p>\n<p>우리는 이 조정하는 과정을 <strong>projection transform</strong>이라고 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABFElEQVQY012Ra07DMBCEe/9DwQ9OQBEVrZO2pKZJsWM78aN2+hi0WwGFlVaWpfGnmfHsfD7DWgvvPUopuJ/r9Yp4jHzeb4wRKSUYZzD6ESEEEIdmRpDROUzTBOccw0kc4sQClRT+jxsGTLlg3+9hvYEzFjnnG/CUM+qXOeTbAurzgGEY0LYt5q81lFJYbRdwPsPHwgkoiV7XcN0B9a7GWr5js92xSwZeLheslks8PT5ACMHuuq7D80sFKSXWQqAfEnz6BW6EgGx2sNZA9xbyo+MaGEhRSZQp+jjCGMPONtuWBSFGHFP8E1n3PWvJ1TElaK3uIp9O3B1FJXcMCQFVVfG9aRpo3f98Ei3pv5feaa1Ryq3zL0cqy47Z4XJJAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"projection\"\n        title=\"projection\"\n        src=\"/static/054a3161a9b1c6e86a06dc979b304300/37523/projection.png\"\n        srcset=\"/static/054a3161a9b1c6e86a06dc979b304300/e9ff0/projection.png 180w,\n/static/054a3161a9b1c6e86a06dc979b304300/f21e7/projection.png 360w,\n/static/054a3161a9b1c6e86a06dc979b304300/37523/projection.png 720w,\n/static/054a3161a9b1c6e86a06dc979b304300/302a4/projection.png 1080w,\n/static/054a3161a9b1c6e86a06dc979b304300/07a9c/projection.png 1440w,\n/static/054a3161a9b1c6e86a06dc979b304300/1ffbd/projection.png 2108w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>사실 l1과 l2는 원근법에 의해서 길이가 같게 보이는 것인데, projection transform을 하는 순간, 3차원 공간이기 때문에 그냥 같아지는 것이 된다.</li>\n</ul>\n<p>컴퓨터 그래픽스에서는 투영을 시킬 때, 3차원의 모습을 2차원으로 바꿔서 투영시키는 방식이 아닌, 3차원을 그대로 유지하면서 투영의 효과(원근법과 같은)를 달성할 수 있는 것이다.</p>\n<br/>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 16.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAx0lEQVQI102OwUrDQBiE89i+gVK8SRUPPoAgeNBePAntpYIggaiHmpC22oTsn03cDZtkg58keHDgY+Y0M4ExhjzPcc7RdR3e+8ld6/ivnz9fRMJs9YV+ucY+HLEMI46XGdunW7LHcwIRoWmaiTHX9fc0UIqm6i1Jk6KqCqU0+/aTdzkQxZpDEfORrdns9oRJQVy+keavBGNR3/cMwzA9G1FS4O3Asws5KWckVYoozby+4N7e4aVlZdacmjPSeosuhUt7xY1d8AvDWtweJtKsYwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"matrixOfProjection\"\n        title=\"matrixOfProjection\"\n        src=\"/static/ab81fc20e4aee6710fb1a895c91ef83a/37523/matrixOfProjection.png\"\n        srcset=\"/static/ab81fc20e4aee6710fb1a895c91ef83a/e9ff0/matrixOfProjection.png 180w,\n/static/ab81fc20e4aee6710fb1a895c91ef83a/f21e7/matrixOfProjection.png 360w,\n/static/ab81fc20e4aee6710fb1a895c91ef83a/37523/matrixOfProjection.png 720w,\n/static/ab81fc20e4aee6710fb1a895c91ef83a/302a4/matrixOfProjection.png 1080w,\n/static/ab81fc20e4aee6710fb1a895c91ef83a/07a9c/matrixOfProjection.png 1440w,\n/static/ab81fc20e4aee6710fb1a895c91ef83a/701e9/matrixOfProjection.png 1780w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>따라서 초기에 주어진 <strong>fovy</strong>, <strong>aspect</strong>, <strong>n</strong>, <strong>f</strong> 이렇게 4가지의 파라미터가 주어진다면, 내가 카메라 공간의 어느 부분을 보겠다라는 것을 정의하는 것과 같다.</p>\n<ul>\n<li>\n<p>강체변환(rigid-body)과 비강체변환의 차이를 알 수 있다.</p>\n</li>\n<li>\n<p>레스터라이저에서는 LHS로 하드웨어가 설정되어 있기 때문에, Vertex Shaders는 RHS로 처리된 좌표를 LHS로 변환해서 레스터라이저로 전달해야 한다. (<strong>z-negation</strong>) → only 3행만.</p>\n</li>\n</ul>\n<br/>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#gpu-rendering-pipeline\">GPU Rendering Pipeline</a></p>\n</li>\n<li>\n<p><a href=\"#vertex-shader\">Vertex Shader</a></p>\n<ul>\n<li><a href=\"#camera-space\">Camera Space</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#view-transform\">View Transform</a></p>\n<ul>\n<li><a href=\"#right-hand-vs-left-hand\">Right-hand vs Left-hand</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#view-frustum\">View Frustum</a></p>\n<ul>\n<li><a href=\"#view-frustum-culling\">View Frustum Culling</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#projection-transform\">Projection Transform</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 25, 2024","title":"OpenGL ES 3차원 컴퓨터그래픽스 정점 처리","categories":"OpenGL","author":"ALEX","emoji":"🥽"},"fields":{"slug":"/opengl-vertex-processing/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://dongckim.github.io","comments":{"utterances":{"repo":"dongckim/dongckim.github.io"}}}}},"pageContext":{"slug":"/opengl-es-shader/","nextSlug":"/opengl-vertex-processing/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}